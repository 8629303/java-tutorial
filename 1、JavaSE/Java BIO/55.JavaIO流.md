> 1. 史上最骚最全最详细的IO流教程，小白都能看懂！https://blog.csdn.net/qq_44543508/article/details/102831084
> 2. Java中IO流的分类和BIO,NIO,AIO的区别：https://blog.csdn.net/QLH04_04/article/details/93646742
> 3. java IO流学习（星期天去哪玩o）：https://www.cnblogs.com/wengshuhang/p/10133020.html
> 4. Java中IO流原理及流的分类（伊万夫斯基）：https://www.cnblogs.com/benjieqiang/p/11461886.html
> 5. https://www.cnblogs.com/henuliulei/p/14002788.html
> 6. https://www.cnblogs.com/hopeyes/p/9736642.html
> 7. http://www.yiidian.com/java-io/what-is-java-io.html
> 8. 系统学习 Java IO----目录，概览：https://www.jianshu.com/p/89a171f2d958

> Java IO编程可以说是所有语言之最，它为了方便进行IO（Input & Output）提供有大量程序类支持，在整个`java.io`包里面核心的组成为：一个类（File）、一个接口（Serializable）、四个抽象类（InputStream、OutputStream、Reader、Writer）
>



在`java.io`包里面File类是唯一一个与文件本身有关的程序处理类，File只能操作文件本身不能操作文件的内容，或者是在实际的开发之中I/O操作的核心意义在于：输入与输出操作。而对于程序而言，输入与输出可能来自于不同的环境，例如：通过电脑连接服务器上进行浏览的时候，实际上此时客户端发出了一个信息，而后服务器接收到此信息之后进行回应处理。

对于服务器或者是客户端而言实质上传递的就是一种数据流的处理形式，而所谓的数据流指就是字节数据。而对于这种流的处理形式在`java.io`包里面提供有两类支持：

- 字节处理流：InputStream（输入字节流）、OutputStream（输出字节流）
- 字符处理流：Reader（输入字符流）、Writer（输出字符流）



# File文件操作

## 1、File 类基本使用

File类是java.io包里唯一一个与文件本身有关的操作类，File类是Comparable接口的子类，如下是FIle常用方法：

| 方法名称                                   | 类型 | 描述              |
| ------------------------------------------ | ---- | ----------------- |
| public File(String pathname)               | 构造 | 需要完整路径      |
| public File(String pathname, String child) | 构造 | 父路径与子目录    |
| public boolean createNewFile()             | 普通 | 创建新文件        |
| public boolean createTemplFile()           | 普通 | 创建临时文件      |
| public boolean exists()                    | 普通 | 判断文件是否存在  |
| public boolean delete()                    | 普通 | 删除文件          |
| public void deleteOnExit()                 | 普通 | JVM退出时删除文件 |

操作示例 1：使用类创建一个文件（D:\test.txt）

```java
public class JavaAPIDemo {
    public static void main(String[] args) throws Exception {
        File file = new File("D:\\xxxx.txt");
        // 判断文件是否存在
        if (file.exists()) {
            file.delete(); // 删除文件
        } else {
            // 文件不存在，创建新的文件
            System.out.println(file.createNewFile()); 
        }
    }
}
```



## 2、File 类操作深入

1、不同系统中换行符也不一样。为了统一标准File提供了一个常量：public static final String separator

```java
File file = new File("D:" + File.separator + "test.txt");
```

2、在使用File类进行文件操作的时候需要注意的是：程序—>JVM—>操作系统函数—>文件处理。所以在进行同一文件的反复删除或创建的时候可能会出现有延迟问题，所以这个时候最好的方案是别重名。

3、在进行文件创建的时候有一个重要的前提，**文件的父路径必须首先存在**

1. 获取父路径：public File getParentFile();
2. 创建目录：public boolean mkdirs();

```java
package cn.mldn.demo;

import java.io.File;

public class JavaAPIDemo {
	public static void main(String[] args) throws Exception {
		File file = new File("d:" + File.separator + "hello" + File.separator + "demo" + File.separator + "message"
				+ File.separator + "mldn.txt");
		if (!file.getParentFile().exists()) {	// 父路径不存在
			file.getParentFile().mkdirs() ; // 创建父路径
		}
		if (file.exists()) {
			file.delete();// 删除文件
		} else { // 文件不存在
			System.out.println(file.createNewFile()); // 创建新的文件
		}
	}
}
```



## 3、综合案例：获取文件信息

1. 判断是否是文件：public boolean isFile()
2. 判断是否是目录：public boolean isDirectory()
3. 文件是否可读：public boolean canRead()
4. 文件是否可写：public boolean canWrite()
5. 获取文件长度：public long length()
6. 获取绝对路径：public String getAbsolutePath()
7. 获取相对路径：public String getPath()
8. 判断文件是否隐藏：public boolean isHidden() 
9. 获取文件或目录名：public String getName()
10. 最后一次修改日期时间：public long lastModified()

操作示例 1：查看文件信息

```java
package cn.mldn.demo;

import java.io.File;
import java.text.SimpleDateFormat;
import java.util.Date;

class MathUtil {
    private MathUtil() {}

    public static double round(double num, int scale) {
        return Math.round(Math.pow(10, scale) * num) / Math.pow(10, scale);
    }
}

public class JavaAPIDemo {
    public static void main(String[] args) throws Exception {
        File file = new File("d:" + File.separator + "my.jpg");
        System.out.println("是目录吗？" + file.isDirectory());
        System.out.println("是文件吗？" + file.isFile());
        System.out.println("文件是否可读：" + file.canRead());
        System.out.println("文件是否可写：" + file.canWrite());
        System.out.println("文件大小：" + MathUtil.round(file.length() / (double) 1024 / 1024, 2));
        System.out.println("最后的修改时间：" + 
                           new SimpleDateFormat("yyyy-MM-dd HH:mm:ss").format(new Date(file.lastModified())));

    }
}
```

操作示例 2：列出目录内容

```java
package cn.mldn.demo;
import java.io.File;

public class JavaAPIDemo {
    public static void main(String[] args) throws Exception {
        File file = new File("d:" + File.separator);
        if (file.isDirectory()) {	// 当前是一个目录
            File result [] = file.listFiles() ; // 列出目录中的全部内容
            for (int x = 0 ; x < result.length ; x ++) {
                System.out.println(result[x]);
            }
        }
    }
}
```



## 4、综合案例：列出目录文件

1. 获取路径表示目录下的所有文件和目录名称：public String[] list()
2. 获取满足过滤器FilenameFilter条件的所有目录或文件：public String[] list(FilenameFilter filter)
3. 获取路径表示目录下的所有文件和目录对象（文件类型）：public File[] listFiles()
4. 获取满足过滤器FilenameFilter条件的所有目录或文件对象（文件类型）：public File[] listFiles(FilenameFilter filter)

范例：列出指定目录中的全部文件

```java
package cn.mldn.demo;
import java.io.File;

public class JavaAPIDemo {
	public static void main(String[] args) throws Exception {
		File file = new File("D:" + File.separator) ;	// 是一个目录
		listDir(file) ;
	}
	public static void listDir(File file) {
		if (file.isDirectory()) {	// 是一个目录
			File results [] = file.listFiles() ; // 列出目录中的全部内容
			if (results != null) {
				for (int x = 0 ; x < results.length ; x ++) {
					listDir(results[x]) ; // 继续依次判断
				}
			}
		}
		System.out.println(file);	// 获得完整路径
        //file.delete() ;
	}
}
```



## 5、综合案例：文件批量更名

范例：批量修改文件名称

```java
package cn.mldn.demo;
import java.io.File;

public class JavaAPIDemo {
    public static void main(String[] args) throws Exception {
        File file = new File("D:" + File.separator + "test") ;	// 是一个目录
        long start = System.currentTimeMillis() ;
        renameDir(file) ;
        long end = System.currentTimeMillis() ;
        System.out.println("本次操作所花费的时间：" + (end - start));
    }
    public static void renameDir(File file) {
        if (file.isDirectory()) {	// 是一个目录
            File results [] = file.listFiles() ; // 列出子目录中的内容
            if (results != null) {
                for (int x = 0 ; x < results.length ; x ++) {
                    renameDir(results[x]) ;
                }
            }
        } else {
            if (file.isFile()) {	// 如果是文件则必须进行重命名
                String fileName = null ; 
                if (file.getName().contains(".")) {
                    fileName = file.getName().substring(0,file.getName().lastIndexOf(".")) + ".txt" ;
                } else {
                    fileName = file.getName() + ".txt" ;
                }
                File newFile = new File(file.getParentFile(),fileName) ; // 新的文件名称
                file.renameTo(newFile) ; // 重命名
            }
        }
    }
}
```



# 字节流和字符流

## 1、字节输入流：InputStream

`InputStream`抽象类主要实现的就是字节数据读取，是表示字节输入流的所有类的超类（父类），该类定义如下：

```java
public abstract class InputStream extends Object implements Closeable {}
```

`InputStream`类实现了`Closeable`父接口，所以在数据输入完毕后需要进行流的关闭。其常用方法如下：

| 方法名                               | 描述                                             |
| ------------------------------------ | ------------------------------------------------ |
| abstract int read()                  | 读取单个字节数据，如果读完返回-1                 |
| int read(byte[] b)                   | 读取一组字节数据，返回是读的个数，如果读完返回-1 |
| int read(byte[] b, int off, int len) | 读取一组字节数据（只占数字的部分）               |
| void close()                         | 关闭输出流                                       |
| byte[] readAllBytes()                | 读取输入流全部字节数据，JDK1.9新增               |
| long transferTo(OutputStream out)    | 输入流转存到输出流，JDK1.9新增                   |

`InputStream`是抽象类，这时应该依靠它的子类来实例化对象，如果要从文件读取要使用`FileInputStream`子类，对于子类而言只关心父类对象实例化。

| 构造方法                              | 描述                                                         |
| ------------------------------------- | ------------------------------------------------------------ |
| FileInputStream(File file)            | 通过打开一个到实际文件的连接来创建FileInputStream，该文件通过文件系统中的File对象file指定 |
| FileInputStream(String name)          | 通过打开一个到实际文件的连接来创建FileInputStream，该文件通过文件系统中的路径名name指定 |
| FileInputStream(FileDescriptor fdObj) | 通过使用文件描述符fdObj创建FileInputStream，该文件描述符表示到文件系统中某个实际文件的现有连接 |

> 注意：当你创建一个流对象时，必须传入一个文件路径。该路径下，如果没有该文件,会抛出`FileNotFoundException` 。
> 如上每个构造方法都有抛异常：`throws FileNotFoundException`

---

操作示例 1：读取字节：`read`方法，每次可以读取一个字节的数据，参数为int类型，读取到文件末尾则返回-1【read.txt文件中内容为abcde】：

```java
package com.example;

import java.io.FileInputStream;
import java.io.IOException;

public class FileInputStreamDemo {
    public static void main(String[] args) throws IOException {
        // 使用文件名称创建流对象，read.txt文件中内容为abcde
        FileInputStream fis = new FileInputStream("D:\\read.txt");
        // 读取数据，返回一个字节
        int read = fis.read();
        System.out.println((char) read);
        read = fis.read();
        System.out.println((char) read);
        read = fis.read();
        System.out.println((char) read);
        read = fis.read();
        System.out.println((char) read);
        read = fis.read();
        System.out.println((char) read);
        // 读取到末尾,返回-1
        read = fis.read();
        System.out.println( read);
        // 关闭资源
        fis.close();
    }
}

// 输出结果
a
b
c
d
e
-1
```

循环方式读取，代码使用演示：

```java
package com.example;

import java.io.FileInputStream;
import java.io.IOException;
import java.io.InputStream;

public class FileInputStreamDemo {
    public static void main(String[] args) throws IOException {
        // 使用文件名称创建流对象，并且自动关闭流
        try (InputStream input = new FileInputStream("D:\\read.txt");) {
            // 定义变量，保存数据
            int len;
            // 循环读取
            while ((len = input.read()) != -1) {
                System.out.println((char) len + "、" + len);
            }
        }
    }
}

// 输出结果
a、97
b、98
c、99
d、100
e、101
```



操作示例 2：使用字节数组读取：`read(byte[] b)`，每次读取b的长度个字节到数组中，返回读取到的有效字节个数，读取到末尾时返回-1（每次读取2个字节的数据）【read.txt文件中内容为abcde】：

```java
package com.example;

import java.io.FileInputStream;
import java.io.IOException;
import java.io.InputStream;

public class FileInputStreamDemo {
    public static void main(String[] args) throws IOException {
        // 使用文件名称创建流对象，并且自动关闭流
        try (InputStream input = new FileInputStream("D:\\read.txt")) {
            // 定义变量，保存数据
            int len;
            byte[] data = new byte[2];
            // 循环读取
            while (( len= input.read(data))!=-1) {
                // 每次读取后,把数组变成字符串打印
                System.out.println(new String(data));
            }
        }
    }
}

// 输出结果
ab
cd
ed
```

由于`read.txt`文件中内容为`abcde`，而错误数据`d`，是由于最后一次读取时，只读取一个字节`e`，数组中，上次读取的数据没有被完全**替换**【注意是替换，看下图】，所以要通过`len` ，获取有效的字节

```
第一次读：    a      b                = ab
第二次读：    a->c   b->d             = cd
第三次读：    c->e   d->no replace    = ed

共5个数据，一次读取2个，第三次只能被替换一个，最后没有被替换的也一起读取了
```



操作示例 3：读取指定长度字节数组：`read(byte[] b, int off, int len)`，每次从off索引开始，len个字节，此方法能解决示例 2中的读错数据问题

```java
package com.example;

import java.io.FileInputStream;
import java.io.IOException;
import java.io.InputStream;

public class FileInputStreamDemo {
    public static void main(String[] args) throws IOException {
        // 使用文件名称创建流对象，并且自动关闭流
        try (InputStream input = new FileInputStream("D:\\read.txt")) {
            // 定义变量，保存数据
            int len;
            byte[] data = new byte[2]; // 一般情况下byte数组会使用1024来接收
            // 循环读取
            while (( len= input.read(data))!=-1) {
                // 每次读取后,把数组变成字符串打印, len 每次读取的有效字节个数
                System.out.println(new String(data, 0, len));
            }
        }
    }
}

// 输出结果
ab
cd
e
```

PS：在开发中一般强烈推荐使用数组读取文件

---

在使用`FileInputStream`读取文件内的中文字符时可能会出现乱码的情况，下面我们来模拟和解决这类问题【read.txt文件中内容为：你好啊今天出去玩吗】

操作示例 4：一次性读取中文数据，下面2案例分别定义1024个字节数组与26个字节数组来接收保存的数据

```java
package com.example;

import java.io.FileInputStream;
import java.io.IOException;
import java.io.InputStream;

public class FileInputStreamDemo {
    public static void main(String[] args) throws IOException {
        try (InputStream input = new FileInputStream("D:\\read.txt")) {
            // 开辟一个缓冲区读取数据
            byte[] data = new byte [1024] ;
            // 读取数据，数据全部保存在字节数组之中，返回读取个数
            int len = input.read(data) ;
            System.out.println(new String(data, 0, len));
        }
    }
}

// 输出结果
你好啊今天出去玩吗
```

```java
package com.example;

import java.io.FileInputStream;
import java.io.IOException;
import java.io.InputStream;

public class FileInputStreamDemo {
    public static void main(String[] args) throws IOException {
        try (InputStream input = new FileInputStream("D:\\read.txt")) {
            // 开辟一个缓冲区读取数据
            byte[] data = new byte [26] ;
            // 读取数据，数据全部保存在字节数组之中，返回读取个数
            int len = input.read(data) ;
            System.out.println(new String(data, 0, len));
        }
    }
}

// 输出结果
你好啊今天出去玩�
```

> 结论：可以发现定义为1024个字节数组的代码读取的中文输出正常，而定义为26个字节数组的代码读取数据就会出现乱码，这是因为不同编码格式下，一个中文汉字的字节数是不一样的，以UTF-8格式为例，其占字节数为3。而本人IDEA中设置的编码为`UTF-8`。



操作示例 5：循环读取文件内的中文数据，每次固定读取3字节数组（如果设置为1024，并且读取UTF-8的中文，当中文过长可是会出现一些乱码状况）

```java
package com.example;

import java.io.FileInputStream;
import java.io.IOException;
import java.io.InputStream;

public class FileInputStreamDemo {
    public static void main(String[] args) throws IOException {
        try (InputStream input = new FileInputStream("D:\\read.txt")) {
            // 开辟一个缓冲区读取数据
            byte[] data = new byte [3] ;
            // 读取数据，数据全部保存在字节数组之中，返回读取个数
            int len ;
            while ((len = input.read(data)) != -1) {
                System.out.println(new String(data, 0, len));
            }
        }
    }
}

// 输出结果
你
好
啊
今
天
出
去
玩
吗
```



操作示例 6：JDK 1.9开始`InputStream`类里面增加了一个新的方法：`public byte[] readAllBytes() throws IOException`

```java
package com.example;

import java.io.FileInputStream;
import java.io.IOException;
import java.io.InputStream;

public class FileInputStreamDemo {
    public static void main(String[] args) throws IOException {
        try (InputStream input = new FileInputStream("D:\\read.txt")) {
            // 读取全部数据
            byte[] data = input.readAllBytes() ;
            System.out.println(new String(data));
        }
    }
}

// 输出结果
你好啊今天出去玩吗
```





## 2、字节输出流：OutputStream

字节的数据是以byte类型为主实现的，在进行字节内容输出的时候可以使用OutputStream类完成，这个类的基本定义：

```java
public abstract class Outputstream extends Object implements Closeable, Flushable {}
```

在Outputstream类中实现了两个父接口：Closeable、Flushable，这两个接口的定义组成分别如下：

```java
// JDK1.5 提供
public interface Closeable extends AutoCloseable {
    public void close() throws IOException;
}
// JDK1.5 提供
public interface Flushable {
    public void flush() throws IOException;
}
```

这两个父接口是从JDK1.5后提供的，而在JDK1.5前，close()、flush()两个方法都是直接定义在Outputstream类中的。

OutputStream 类定义的是一个公共的输出操作标准，而这个操作标准里面定义了三个内容输出和两个父接口的方法：

| 方法名                                                       | 描述             |
| ------------------------------------------------------------ | ---------------- |
| public abstract void write(int b) throws IOException         | 输出单个字节数据 |
| public void write(byte[] b) throws IOException               | 输出一组字节数据 |
| public void write(byte[] b,int off, int len) throws IOException | 输出部分字节数据 |
| public void close() throws IOException                       | 关闭输出流       |
| public void flush() throws IOException                       | 刷新缓冲区       |

但是需要注意的一个核心问题在于：`OutputStream`类毕竟是一个抽象类，而这个抽象类如果向获得实例化对象，按照传统的认识应该通过子类实例化向上转型完成，如果说现在要进行的是文件处理操作。则可以使用**`FileOutputStream`**子类。

因为最终都需要发生向上转型的处理关系，所以对于此时的`FileOutputStream`子类核心的关注点就可以放在构造方法：

| 构造方法                                      | 描述                                                         |
| --------------------------------------------- | ------------------------------------------------------------ |
| FileOutputStream(File file)                   | 创建一个向指定 `File` 对象表示的文件中写入数据的文件输出流【覆盖】 |
| FileOutputStream(File file, boolean append)   | 创建一个向指定 `File` 对象表示的文件中写入数据的文件输出流【追加】 |
| FileOutputStream(String name)                 | 创建一个向具有指定名称的文件中写入数据的输出文件流【覆盖】   |
| FileOutputStream(String name, boolean append) | 创建一个向具有指定名称的文件中写入数据的输出文件流【追加】   |
| FileOutputStream(FileDescriptor fdObj)        | 创建一个向指定文件描述符处写入数据的输出文件流，<br />该文件描述符表示一个到文件系统中的某个实际文件的现有连接 |

推荐第二种构造方法【开发常用】：`FileOutputStream fos = new FileOutputStream("D:\\out.txt");`，创建字节输出流对象都做了三件事情：

1. 调用系统功能去创建文件【输出流对象才会自动创建】
2. 创建outputStream对象
3. 把foutputStream对象指向这个文件

> 注意：创建输出流对象的时候，系统会自动去对应位置创建对应文件，而创建输出流对象的时候，文件不存在则会报FileNotFoundException异常，也就是系统找不到指定的文件异常。
>
> 当你创建一个流对象时，必须直接或者间接传入一个文件路径。比如现在我们创建一个`FileOutputStream`流对象，在该路径下，如果没有这个文件，会创建该文件。如果有这个文件，会清空这个文件的数据。

---

操作示例 1：输出字节：`write(int b)` 方法，每次可以写出一个字节数据，代码如下：

```java
package com.example;
import java.io.FileOutputStream;

public class FileOutputStreamDemo {
    public static void main(String[] args) throws Exception {
        // 使用文件名称创建流对象
        FileOutputStream fos = new FileOutputStream("D:\\out.txt");
        // 写出数据
        fos.write(97); // 写出第1个字节
        fos.write(98); // 写出第2个字节
        fos.write(99); // 写出第3个字节
        // 关闭资源
        fos.close();
    }
}
// 输出结果：abc
```

PS：虽然参数为int类型四个字节，但是只会保留一个字节的信息写出。



操作示例 2：输出全部字节数组：write(byte[] b)，每次可以写出数组中的数据，代码使用演示：

```java
package com.example;

import java.io.File;
import java.io.FileOutputStream;
import java.io.OutputStream;

public class FileOutputStreamDemo {
    public static void main(String[] args) throws Exception {
        // 1、指定要操作的文件的路径
        File file = new File("D:" + File.separator + "out.txt");
        // 2、判断父目录是否存在，如果不存在就创建父目录
        if (!file.getParentFile().exists()) {
            file.getParentFile().mkdirs();
        }
        // 3、通过子类实例化
        OutputStream output = new FileOutputStream(file);
        // 4、将要输出的字符串变为字节数组并输出
        output.write("hello".getBytes());
        // 5、关闭资源
        output.close();
    }
}
```



操作示例 3：写出指定长度字节数组：`write(byte[] b, int off, int len)`，每次写出从off索引开始，len个字节，代码如下：

```java
package com.example;
import java.io.FileOutputStream;

public class FileOutputStreamDemo {
    public static void main(String[] args) throws Exception {
        // 使用文件名称创建流对象
        FileOutputStream fos = new FileOutputStream("D:\\out.txt");
        // 字符串转换为字节数组
        byte[] b = "abcde".getBytes();
        // 写出从索引2开始，2个字节。索引2是c，两个字节，也就是cd。
        fos.write(b,2,2);
        // 关闭资源
        fos.close();
    }
}
// 输出结果：cd
```



操作示例 4：实现内容的追加与换行，并且使用AutoCloseable自动关闭流处理（JDK1.7后支持）

```java
package com.example;

import java.io.File;
import java.io.FileOutputStream;
import java.io.IOException;
import java.io.OutputStream;

public class FileOutputStreamDemo2 {
    public static void main(String[] args) {
        // 1、指定要操作的文件的路径
        File file = new File("D:" + File.separator + "out.txt");
        // 2、判断父目录是否存在，如果不存在就创建父目录
        if (!file.getParentFile().exists()) {
            file.getParentFile().mkdirs();
        }
        // 追加操作与自动关闭处理
        try (OutputStream output = new FileOutputStream(file, true)) {
            // 3、将要输出的字符串变为字节数组并输出
            output.write("hello\r\n".getBytes());
        } catch (IOException e) {
            e.printStackTrace();
        }
    }
}
```

> 回车符\r和换行符\n ：
>
> 1. 回车符：回到一行的开头（return）
> 2. 换行符：下一行（newline）
>
> 系统中的换行：
>
> 1. Windows系统里，每行结尾是 回车+换行 ，即\r\n
> 2. Unix系统里，每行结尾只有 换行 ，即\n
> 3. Mac系统里，每行结尾是 回车 ，即\r。从 Mac OS X开始与Linux统一





## 3、字符输入流：Reader

`Reader`是实现字符输入流的一种类型，可以实现char数据类型的读取

```java
public abstract class Reader implements Readable, Closeable {}
```

`Reader`类实现了`Readable`接口和`Closeable`接口，其中`Readable`接口时在JDK1.5提供的，可以实现缓冲区的数据读取，接口定义如下：

```java
public interface Readable {
    public int read(java.nio.CharBuffer cb) throws IOException;
}
```

`Reader`类定义了字符数据的读取方法，常用方法如下：

| 方法名                                                       | 描述                              |
| ------------------------------------------------------------ | --------------------------------- |
| public int read() throws IOException                         | 读取单个字符，读完则返回-1        |
| public int read(char[] chuf) throws IOException              | 读取一组字符，读完则返回-1        |
| public int read(char[] chuf, int off, int len) throws IOException | 读取一组字节数据（只占len的部分） |
| public long skip(long n) throws IOException                  | 跳过指定的字符个数后读取          |
| public boolean ready() throws IOException                    | 是否可以开始读取数据              |
| public abstract void close() throws IOException              | 关闭输入流                        |

`Reader`是抽象类，通过文件读取数据可以使用`FileReader`子类实现实例化，`FileReader`类的构造方法如下：

| 构造方法                                                     | 描述                                                 |
| ------------------------------------------------------------ | ---------------------------------------------------- |
| public FileReader(File file) throws FileNotFoundException    | 创建一个新的FileReader，给定要读取的File对象         |
| public FileReader(String fileName) throws FileNotFoundException | 创建一个新的FileReader，给定要读取的文件的字符串名称 |

操作示例 1：实现数据读取

```java
package com.example;

import java.io.File;
import java.io.FileReader;
import java.io.Reader;

public class JavaAPIDemo {
    public static void main(String[] args) throws Exception {
        File file = new File("D:" + File.separator + "read.txt");
        // 文件存在则进行读取
        if (file.exists()) {
            // 1.单个字符读取
            Reader in1 = new FileReader(file);
            int len1;
            while ((len1 = in1.read()) != -1) {
                System.out.println((char) len1 + "、" + len1);
            }
            in1.close();

            // 2.字符数组读取
            Reader in2 = new FileReader(file);
            char[] data = new char[1024];
            int len2;
            while ((len2 = in2.read(data)) != -1) {
                System.out.println(new String(data, 0, len2));
            }
            in2.close();

            // 3.跨过3个字符长度
            Reader in3 = new FileReader(file);
            char[] data3 = new char[1024];
            in3.skip(3);
            int len3 = in3.read(data3);
            System.out.println(new String(data, 0, len3));
            in3.close();
        }
    }
}

// 输出内容
你、20320
好、22909
啊、21834
今、20170
天、22825
出、20986
去、21435
玩、29609
吗、21527
你好啊今天出去玩吗
你好啊今天出
```





## 4、字符输出流：Writer

使用`OutputStream`进行字节数据输出，这类数据适合用网络传输，但是在操作时需要进行字节数组的转换。在底层通信处理中都是依靠字节实现数据交互，在程序中为了方便进行中文的数据处理，往往都会采用字符数据类型，所以在JDK1.1的时候又推出了字符串输出流`Writer`：

```java
public abstract class Writer extend Object implement Appendable, Closeable, Flushable {}
```

可以发现比`OutputStream`类多实现了一个`Appendable`接口（此接口从JDK1.5后开始提供），利用此接口可以实现输出内容的追加，此接口定义如下：

```java
public interface Appendable {
    Appendable append(CharSequence csq) throws IOException;
    Appendable append(CharSequence csq, int start, int end) throws IOException;
    Appendable append(char c) throws IOException;
}
```

字符流最大的特点就是可以直接进行字符串的输出，`Writer`类中提供常用方法如下：

| 方法名                                                       | 描述               |
| ------------------------------------------------------------ | ------------------ |
| public Writer append(CharSepquence csq) throws IOException   | 追加输出内容       |
| public void write(int c) throws  IOException                 | 输出单个字符       |
| public void write(char[] chuf) throws IOException            | 输出字符串数组     |
| public abstract void write(char[] cbuf, int off, int len) throws IOException | 输出指定字符串数组 |
| public void write(String str) throws IOException             | 输出字符串         |
| public void write(String str, int off, int len) throws IOException | 输出指定长度字符串 |
| public abstract  void close() throws IOException             | 关闭输出流         |
| public abstract  void flush() throws IOException             | 刷新缓冲区         |

`Writer`类进行文件操作的时候可以利用`FileWriter`子类进行对象实例化，`FileWriter`类的构造方法如下：

| 构造方法                                                     | 描述                                                         |
| ------------------------------------------------------------ | ------------------------------------------------------------ |
| public FileWriter(File file) throws IOException              | 采用覆盖的形式创建文件输出流                                 |
| public FileWriter(File file, boolean append) throws IOException | 采用覆盖或追加形式创建文件输出流                             |
| public FileWriter(String name) throws IOException            | 采用覆盖的形式创建文件名输出流                               |
| public FileWriter(String name, boolean append) throws IOException | 采用覆盖或追加形式创建文件名输出流                           |
| public FileWriter(FileDescriptor fd)                         | 创建输出流，该文件描述符表示一个到文件系统中的某个实际文件的现有连接 |



操作示例 1：使用`FileWriter`输出单个字符、字符串数组、字符串到文件中

```java
package com.example;

import java.io.FileWriter;
import java.io.Writer;

public class JavaAPIDemo {
    public static void main(String[] args) throws Exception {
        try (Writer out = new FileWriter("D:\\out.txt")) {
            // 输出单个字符
            out.write(97);
            out.write('b');
            out.write('C');

            // 写出换行
            out.write("\r\n");

            // 输出字符串数组 和 输出指定字符串数组
            out.write(new char[]{'a', 'b', 'c'});
            out.write("\r\n");
            out.write(new char[]{'a', 'b', 'c'}, 0, 2);

            // 写出换行
            out.write("\r\n");

            // 输出字符串 和 输出指定长度字符串
            out.write("abc");
            out.write("\r\n");
            out.write("abc", 0, 2);
        }
    }
}

// 输出结果
abC
abc
ab
abc
ab
```



操作示例 2：使用Writer输出（会覆盖上次操作）

```java
package com.example;

import java.io.FileWriter;
import java.io.Writer;

public class JavaAPIDemo {
    public static void main(String[] args) throws Exception {
        try (Writer out = new FileWriter("D:\\out.txt")) {
            out.write("你好啊！\r\n");
            // 追加输出内容（这个追加只是在本次操作中追加，如果重新执行main方法由会覆盖了）
            out.append("中国人民万岁。");
        }
    }
}

// 输出结果
你好啊！
中国人民万岁。
```

操作示例 3：使用Writer输出（在上次内容上追加）

```java
package com.example;

import java.io.FileWriter;
import java.io.Writer;

public class JavaAPIDemo {
    public static void main(String[] args) throws Exception {
        try (Writer out = new FileWriter("D:\\out.txt", true)) {
            out.write("你好啊！\r\n");
            out.append("中国人民万岁。"); // 追加输出内容
        }
    }
}

// 输出内容（文件中的内容）
你好啊！
中国人民万岁。你好啊！
中国人民万岁。
```

> 【注意】：FileWriter关闭资源时与FileOutputStream不同。 如果不关闭，数据只是保存到缓冲区，并未保存到文件

***

**关闭close() 和 刷新flush() 方法总结：**

因为内置缓冲区的原因，如果不关闭输出流，无法写出字符到文件中。但是关闭的流对象，是无法继续写出数据的。如果我们既想写出数据，又想继续使用流，就需要`flush()`方法了。

1. flush() ：刷新缓冲区，流对象可以继续使用
2. close()：先刷新缓冲区，然后通知系统释放资源。流对象不可以再被使用了



## 5、字节与字符流的区别

虽然`java.io`包中提供字节流和字符流两类处理支持类，但是在数据传输（或保存磁盘）时所操作的数据依然为字节数据，字符数据都是通过缓冲区进行处理后得到的内容。

```
 ------------------OutputStream、InputStream-----------------
 ⬆⬆                                                        ⬆⬇     10001110
程序-----> Writer、Reader ---->  字符 ---->  缓存  <-----   字节  <----------> 计算机
                                             ⬇
                                    将字节数据转化为字符数据
```

两类操作流最大的区别在于字符流使用到了缓冲区（这样更适合进行中文数据的操作），而字节流时直接进行数据处理操作。所以当使用字符输出流进行输出时就必须使用`Flushable`接口中提供的`flush()`方法强制性刷新缓冲区中的内容了，否则数据将不会输出。

操作示例 1：字符流输出并强制刷新缓冲区

```java
package com.example;

import java.io.FileWriter;
import java.io.Writer;

public class JavaAPIDemo {
    public static void main(String[] args) throws Exception {
        Writer out = new FileWriter("D:\\out.txt") ;
        out.write("你好啊");
        out.flush();  // 强制性刷新
    }
}
```

上面使用`Writer`输出时使用了`flush()`方法，如果不使用将不会输出任务内容到文件中。

在使用`Outputstream`和`Writer`输出的最后发现都使用了`close()`方法进行了关闭处理。

在使用`Outputstream`类输出的时候如果现在没有使用`close()`方法关闭输出流依然可以实现正常的输出，但是如果在使用`Wireter`的时候没有使用`close()`方法关闭输出流，那么整个时候内容将无法进行输出，因为`Writer`使用到了缓冲区，当使用了`close()`方法的时候实际上会出现有强制刷新缓冲区的情况，所以这个时候会将内容进行输出，如果没有关闭，那么将无法进行输出操作，所以此时如果在不关闭的情况下要向将全部内容输出可以使用flush()方法强制性清空。

> 总结：
>
> 1. 字节流在进行处理的时候并不会使用到缓冲区，而字符流会使用到缓冲区
> 2. 使用字符流输出时必须要使用`flush()`进行强制刷新才能把内容写入到文件中
> 3. 当字符流输出时没调用`flush()`方法时想把内容写入到文件也可以直接关闭输出流，字符流关闭时会自动清空缓冲区

# 编码、解码及字符集

## 1、字符编码与解码

众所周知，计算机中储存的信息都是用二进制数表示的，而我们在屏幕上看到的数字、英文、标点符号、汉字等字符是二进制数转换之后的结果。按照某种规则，将字符存储到计算机中，称为编码 。反之，将存储在计算机中的二进制数按照某种规则解析显示出来，称为解码 。比如说，按照A规则存储，同样按照A规则解析，那么就能显示正确的文本符号。反之，按照A规则存储，再按照B规则解析，就会导致乱码现象。

简单点解释：

1. 编码：字符（能看懂的）=》字节（看不懂的）
2. 解码：字节（看不懂的）=》字符（能看懂的）

代码解释则：

```java
String(byte[] bytes, String charsetName) // 通过指定的字符集解码字节数组
byte[] getBytes(String charsetName)      // 使用指定的字符集合把字符串编码为字节数组

String -- byte[]  // 编码:把看得懂的变成看不懂的
byte[] -- String  // 解码:把看不懂的变成看得懂的
```

**字符编码**`Character Encoding`： 就是一套自然语言的字符与二进制数之间的对应规则。而**编码表**则是生活中文字和计算机中二进制的对应规则



## 2、字符集

**字符集**`Charset`：也叫**编码表**。是一个系统支持的所有字符的集合，包括各国家文字、标点符号、图形符号、数字等。

计算机要准确的存储和识别各种字符集符号，需要进行字符编码，一套字符集必然至少有一套字符编码。常见字符集有：`ASCII`、`GBK`、`Unicode`、`ISO8859-1`等

```
ASCII字符集            GBK字符集                         Unicode字符集
   ⬆⬆                    ⬆⬆                                 ⬆⬆
ASCII编码               GBK编码                    UTF8编码/UTF16编码/UTF32编码
```

可见，当指定了**编码**，它所对应的**字符集**自然就指定了，所以**编码**才是我们最终要关心的。

> 常见的编码或者说字符集：
>

ASCII字符集：

1. ASCII（American Standard Code for Information Interchange，美国信息交换标准代码）是基于拉丁字母的一套电脑编码系统，用于显示现代英语，主要包括控制字符（回车键、退格、换行键等）和可显示字符（英文大小写字符、阿拉伯数字和西文符号）
2. 基本的ASCII字符集，使用7位（bits）表示一个字符，共128字符。ASCII的扩展字符集使用8位（bits）表示一个字符，共256字符，方便支持欧洲常用字符

ISO-8859-1字符集：国际通用单字节编码，最多只能表示0~255的字符范围，主要在英文传输中使用，兼容SCII编码

GBxxx字符集：（GB就是国标的意思，是为了显示中文而设计的一套字符集）

1. GB2312：简体中文码表。一个小于127的字符的意义与原来相同。但两个大于127的字符连在一起时，就表示一个汉字，这样大约可以组合了包含7000多个简体汉字，此外数学符号、罗马希腊的字母、日文的假名们都编进去了，连在ASCII里本来就有的数字、标点、字母都统统重新编了两个字节长的编码，这就是常说的"全角"字符，而原来在127号以下的那些就叫"半角"字符了
2. GBK：最常用的中文码表。是在GB2312标准基础上的扩展规范，使用了双字节编码方案，共收录了21003个汉字，完全兼容GB2312标准，同时支持繁体汉字以及日韩汉字等
3. GB18030：最新的中文码表。收录汉字70244个，采用多字节编码，每个字可以由1个、2个或4个字节组成。支持中国国内少数民族的文字，同时支持繁体汉字以及日韩汉字等

Unicode字符集：

1. Unicode：十六进制编码，可以表达任意语言的任意字符而设计，是业界的一种标准，也称为统一码、标准万国码。此编码不兼容ISO-8859-1编码。
2. 它最多使用4个字节的数字来表达每个字母、符号，或者文字。有三种编码方案，UTF-8、UTF-16和UTF-32。最为常用的UTF-8编码。
3. UTF编码：由于Unicode不支持ISO-8859-1编码，而且占用空间更多，，英文字母也需要使用两个字节编码，这样使用UNICODE不便于传输和存储，因此产生了UTF编码。UTF编码兼容ISO-8859-1编码，同时也可以用来表示所有的语言字符，不过UFT编码是不定长编码，每一个字符的长度从1~6个字节不等，一般在中文网页中使用此编码，因为可以节省空间。
4. UTF-8编码：可以用来表示Unicode标准中任何字符，它是电子邮件、网页及其他存储或传送文字的应用中，优先采用的编码。互联网工程工作小组（IETF）要求所有互联网协议都必须支持UTF-8编码。所以，我们开发Web应用，也要使用UTF-8编码。它使用一至四个字节为每个字符编码，编码规则：
   1. 128个US-ASCII字符，只需一个字节编码
   2. 拉丁文等字符，需要二个字节编码
   3. 大部分常用字（含中文），使用三个字节编码
   4. 其他极少使用的Unicode辅助字符，使用四字节编码



操作示例 1：获取本地系统默认编码

```java
package com.example;

public class JavaAPIDemo {
    public static void main(String[] args) throws Exception {
        System.out.println("系统默认编码：" + System.getProperty("file.encoding"));
    }
}

// 输出内容：
系统默认编码：UTF-8
```

PS：从JDK1.9开始，Java中默认的编码为UTF-8。



## 3、编码问题导致乱码

在开发工具IDEA中，使用`FileReader` 读取项目中的文本文件。由于IDEA的设置，都是默认的`UTF-8`编码，所以没有任何问题。但是，当读取Windows系统中创建的文本文件时，由于Windows系统的默认是GBK编码，就会出现乱码。

操作示例 1：【outB.txt 文件内容为：起飞】【文件编码为GBK】

```java
package com.example;

import java.io.FileReader;
import java.io.Reader;

public class JavaAPIDemo {
    public static void main(String[] args) throws Exception {
        int len;
        // 创建流对象,默认UTF8编码。不过文件编码是为GBK的
        try (Reader reader = new FileReader("D:\\outB.txt")) {
            // 使用默认编码字符流读取,乱码,输出：���
            while ((len = reader.read()) != -1) {
                System.out.print((char) len);
            }
        }
    }
}

// 输出内容
���
```

操作示例 2：输出测试

```java
package com.example;

import java.io.FileOutputStream;
import java.io.OutputStream;

public class JavaAPIDemo {
    public static void main(String[] args) throws Exception {

        // 创建流对象,默认UTF8编码
        try (OutputStream os = new FileOutputStream("D:\\out.txt")) {
            // 使用ISO8859-1编码字符流输出,乱码,输出：?????????
            os.write("中华人民共和国万岁".getBytes("ISO8859-1"));
        }
    }
}

// 输出内容
?????????
```

那么如何读取GBK编码的文件呢？ 这个时候就得讲讲转换流了！

> 从另一角度来讲：**字符流 = 字节流 + 编码表**

# 转换流【掌握】

## 1、转换流介绍

1. 转换流：属于字符流。`java.io`包中有两种转换流：`InputStreamReader`、`OutputStreamWriter`
   1. `InputStreamReader`  ：将一个字节的输入流转换为字符的输入流，将`InputStream`转换为`Reader`
   2. `OutputStreamWriter`：将一个字符的输出流转化为字节的输出流，将`Writer`转换为`OutputStream`
2. 作用：提供了在字节流和字符流之间操作类型的转换（设计目的）
3. 解码：字节、字节数组 => 字符数组、字符串
4. 编码：字符数组、字符串 => 字节、字节数组

```
       InputStreamReader（读取字节，解码为字符）
字节 ------------------------------------------> 字符

       OutputStreamWriter（写出字符，编码为字节）
字节 <------------------------------------------ 字符
```

```
数据输出 ---> 字符数据 ---> OutputStreamWriter(字节输出流转换为字符输出流) ---> 字节数据 ---> 输出目标地    （字符流到字节流的桥梁）
                                                                                           ⬇⬇
数据输入 <--- 字符数据 <--- InputStreamReader (字节输入流转换为字符输入流) <--- 字节数据 <--- 输入目标地    （字节流到字符流的桥梁）

  ⬇⬇            ⬇⬇                        ⬇⬇                                 ⬇⬇              ⬇⬇
电脑程序      内存转换                    转换流                               传输            终端
```

转换流类的定义结构和构造方法：

| 转换流             | 构造方法                                    | 继承结构                                          |
| ------------------ | ------------------------------------------- | ------------------------------------------------- |
| OutputStreamWriter | public OutputStreamWriter(OutputStream out) | public class OutputStreamWriter extends Writer {} |
| InputStreamReader  | public InputStreamReader(InputStream in)    | public class InputStreamReader extends Reader {}  |



## 2、InputStreamReader

转换流InputStreamReader是Reader的子类，是从**字节流到字符流的桥梁**。它读取字节，并使用指定的字符集（charset）将其解码为字符。它的字符集可以由名称指定，也可以接受平台的默认字符集。实现的子类有FileReader ，已实现的接口：Closeable, Readable

```
Reader
 └─ InputStreamReader、BufferedReader、StringReader
       └─ FileReader
```

```java
public class InputStreamReader extends Reader {}
```

| 构造方法                                              | 描述                                    |
| ----------------------------------------------------- | --------------------------------------- |
| InputStreamReader(InputStream in)                     | 创建默认字符集的InputStreamReader       |
| InputStreamReader(InputStream in, String charsetName) | 创建指定字符集的InputStreamReader       |
| InputStreamReader(InputStream in, Charset cs)         | 创建给定字符集的InputStreamReader       |
| InputStreamReader(InputStream in, CharsetDecoder dec) | 创建给定字符集解码器的InputStreamReader |

| 成员方法                                                     | 描述                             |
| ------------------------------------------------------------ | -------------------------------- |
| public String getEncoding()                                  | 返回此流使用的字符编码的名称     |
| public int read() throws IOException                         | 读取单个字符                     |
| public int read(char[] buf, int offset, int length) throws IOException | 将字符读入数组中的某一部分       |
| private boolean isOpen()                                     | 此流是否打开                     |
| public boolean ready() throws IOException                    | 此流是否可以读取                 |
| public void close() throws IOException                       | 关闭该流并释放与之关联的所有资源 |

操作示例 1：【outB.txt 文件内容为：起飞】【文件编码为GBK】

```java
import java.io.FileInputStream;
import java.io.InputStreamReader;

public class InputStreamReaderTest {
    public static void main(String[] args) throws Exception {
        // 文件编码为GBK
        int len;
        char[] ch = new char[1024];

        // 创建流对象,默认UTF8编码
        try (InputStreamReader isr = new InputStreamReader(new FileInputStream("D:\\outB.txt"))) {
            // 使用默认编码字符流读取,乱码,输出：���
            while ((len = isr.read(ch)) != -1) {
                System.out.println(new String(ch, 0, len));
            }
        }

        // 创建流对象,指定GBK编码
        try (InputStreamReader isr = new InputStreamReader(new FileInputStream("D:\\outB.txt"), "GBK")) {
            // 使用指定编码字符流读取,正常解析
            while ((len = isr.read(ch)) != -1) {
                System.out.println(new String(ch, 0, len));
            }
        }

    }
}

// 输出内容
��
�
起飞
```

为了达到最高效率，可以考虑在 BufferedReader 内包装 InputStreamReader。例如：

```java
BufferedReader in = new BufferedReader(new InputStreamReader(System.in));
```





## 3、OutputStreamWriter

转换流`java.io.OutputStreamWriter` ：是`Writer`的子类，是**从字符流到字节流的桥梁**（从字面看容易混淆会误以为是字节流转换为字符流）。使用指定的字符集（charset）将字符编码为字节。它的字符集可以由名称指定，也可以接受平台的默认字符集。所有已实现的接口： Closeable, Flushable, Appendable

```
Writer
 └─ OutputStreamWriter、BufferedWriter、StringWriter
       └─ FileWriter
```

| 构造方法                                                 | 描述                                                |
| -------------------------------------------------------- | --------------------------------------------------- |
| OutputStreamWriter(OutputStream out)                     | 创建使用默认字符编码OutputStreamWriter              |
| OutputStreamWriter(OutputStream out, String charsetName) | 创建使用指定字符集的OutputStreamWriter (utf-8、GBK) |
| OutputStreamWriter(OutputStream out, Charset cs)         | 创建使用给定字符集的OutputStreamWriter              |
| OutputStreamWriter(OutputStream out, CharsetEncoder enc) | 创建使用给定字符集编码器的OutputStreamWriter        |

| 成员方法                                                     | 描述                                             |
| ------------------------------------------------------------ | ------------------------------------------------ |
| public String getEncoding()                                  | 返回此流使用的字符编码的名称                     |
| void flushBuffer() throws IOException                        | 将输出缓冲区刷新到底层字节流，而不刷新字节流本身 |
| public void write(int c) throws IOException                  | 写入单个字符                                     |
| public void write(char[] cbuf, int off, int len) throws IOException | 写入字符数组的某一部分                           |
| public void write(String str, int off, int len) throws IOException | 写入字符串的某一部分                             |
| public void flush() throws IOException                       | 刷新该流的缓冲                                   |
| public void close() throws IOException                       | 关闭此流，但要先刷新它                           |

操作示例 2：

```java
package com.example;

import java.io.FileOutputStream;
import java.io.OutputStreamWriter;

public class JavaAPIDemo {
    public static void main(String[] args) throws Exception {
        // 创建流对象，使用默认编码UTF-8
        try (OutputStreamWriter osw = new OutputStreamWriter(new FileOutputStream("D:\\outA.txt"))) {
            // 写出数据，保存为6个字节
            osw.write("原地");
        }

        // 创建流对象，指定GBK编码
        try (OutputStreamWriter osw2 = new OutputStreamWriter(new FileOutputStream("D:\\outB.txt"), "GBK")) {
            // 写出数据，保存为4个字节
            osw2.write("起飞");
        }
    }
}

// 输出内容
原地
起飞
```

为了获得最高效率，可考虑将 OutputStreamWriter 包装到 BufferedWriter 中，以避免频繁调用转换器。例如：

```java
Writer out = new BufferedWriter(new OutputStreamWriter(System.out));
```









## 4、转换流和子类区别

`OutputStreamWriter`和`InputStreamReader`是字符和字节的桥梁：也可以称之为字符转换流。字符转换流原理：字节流+编码表。

`FileWriter`和`FileReader`作为子类，仅作为操作字符文件的便捷类存在。当操作的字符文件，使用的是默认编码表时可以不用父类，而直接用子类就完成操作了，简化了代码。

```java
// 默认字符集
InputStreamReader isr = new InputStreamReader(new FileInputStream(“a.txt”));
// 指定GBK字符集
InputStreamReader isr = new InputStreamReader(new FileInputStream(“a.txt”),“GBK”);
// 默认字符集
FileReader fr = new FileReader(“a.txt”);
```

> 字符流的读取和写出有以下两种方式：
>
> 1. `FileReader`和`FileWriter`
> 2. `InputStreamReader`和`OutputStreamWriter`
>
> 两种方式的区别是：
>
> 1. `FileReader`和`FileWriter`使用默认的字符编码和字节缓冲区进行字符流传输，是`InputStreamReader`和 `OutputStreamWriter`的子类，也是他们的简化用法
> 2. `InputStreamReader`和`OutputStreamWriter`既可以用默认的字符编码和字节缓冲区大小进行字符流的传输，也可以指定字符编码和字节缓冲区进行字符流的传输



# 内存流【掌握部分】

内存操作流实际就是用于操作数组和字符串的流对象。内存操作流是以内存作为操作终端实现`I/O`数据处理，与文件操作不同在于，内存流不会进行磁盘操作，用来操作处理临时存储的信息。所以，关闭这些流都是无效的，因为这些都未调用系统资源，不需要抛IO异常。常用内存操作流如下：

1. 字节内存操作流（操作字节数组）：`ByteArrayInputStream`、`ByteArrayOutputStream` 
2. 字符内存操作流（操作字符数组）：`CharArrayReader`、`CharArrayWrite`
3. 字符串内存操作流（操作字符串）：`StringReader`、`StringWriter`

## 1、字节内存操作流

> 下面以字节内存操作流为例讲解学习：

ByteArrayInputStream的构造方法与成员方法

```java
public class ByteArrayInputStream extends InputStream {}
```

| 方法名                                                       | 类型 | 描述                                                         |
| ------------------------------------------------------------ | ---- | ------------------------------------------------------------ |
| public ByteArrayInputStream(byte buf[])                      | 构造 | 创建一个新的字节数组输入流，该输入流使用buf作为其缓冲区数组  |
| public ByteArrayInputStream(byte buf[], int offset, int length) | 构造 | 同上一样创建一个新的字节数组输入流，该数组可以从数组中读取指定的len字节数据 |
| int read()                                                   | 普通 | 读取单个字节数据，读完返回-1                                 |
| int read(byte b[], int off, int len)                         | 普通 | 读取一组字节数据（只占数字的部分）如果读完返回-1             |
| int read(byte[] b) throws IOException                        | 普通 | 读取一组字节数据，返回是读的个数，如果读完返回-1（父接口InputStream的方法） |
| int available()                                              | 普通 | 用于返回可从输入流读取的剩余字节数                           |
| boolean markSupported()                                      | 普通 | 用于测试输入流的标记和重置方法                               |
| long skip(long n)                                            | 普通 | 用于从输入流中跳过x个输入字节                                |
| mark(int readAheadLimit)                                     | 普通 | 用于设置流中的当前标记位置                                   |
| void reset()                                                 | 普通 | 用于重置字节数组的缓冲区                                     |
| void close() throws IOException                              | 普通 | 关闭输出流                                                   |

ByteArrayOutputStream的构造方法与成员方法

```java
public class ByteArrayOutputStream extends OutputStream {}
```

| 方法名                                                       | 类型 | 描述                                                         |
| ------------------------------------------------------------ | ---- | ------------------------------------------------------------ |
| public ByteArrayOutputStream()                               | 构造 | 内存当中创建一个字节数组输出流，初始容量为32字节             |
| public BuyteArrayoutputStream(int size)                      | 构造 | 内存当中创建一个指定大小的字节数组输出流                     |
| void write(int b)                                            | 普通 | 用于将指定的字节写入字节数组输出流                           |
| void write(byte b[], int off, int len)                       | 普通 | 用于写入len个从指定字节数组从起始字节偏移量断在字节数组输出流 |
| void writeTo(OutputStream out) throws IOException            | 普通 | 用于将字节数组输出流的完整内容写入指定的输出流               |
| int size()                                                   | 普通 | 用于返回缓冲区的当前大小                                     |
| byte[] toByteArray()                                         | 普通 | 用于创建新分配的字节数组（重要）                             |
| String toString()                                            | 普通 | 用于使用平台默认字符集将内容转换为解码字节的字符串（重要）   |
| String toString(String charsetName) throws UnsupportedEncodingException | 普通 | 用于使用指定的charsetName将内容转换为解码字节的字符串        |
| void reset()                                                 | 普通 | 用于将字节数组输出流的计数字段重置为零值                     |
| void close()                                                 | 普通 | 用于关闭ByteArrayOutputStream                                |

操作示例 1：简单介绍与操作

```java
package com.example;

import java.io.ByteArrayInputStream;
import java.io.ByteArrayOutputStream;

/**
 * 内存操作流：用户处理临时存储信息的，程序结束，数据就从内存消失。
 * 字节数组：ByteArrayInputStream、ByteArrayOutputStream
 * 字符数据：CharArrayReader、CharArrayWrite 
 * 字符串：StringReader、StringWriter   
 */
public class JavaAPIDemo {
    public static void main(String[] args) throws Exception {
        // 写数据
        ByteArrayOutputStream baos = new ByteArrayOutputStream();
        baos.write("hello!".getBytes());
        // 释放资源,通过查看源码发可以发现这里什么都没做，所以根本不需要close()
        //baos.close();

        byte[] bytes = baos.toByteArray();

        // 读取数据
        ByteArrayInputStream bais = new ByteArrayInputStream(bytes);
        int len;
        while ((len = bais.read()) != -1) {
            System.out.print((char)len);
        }
        bais.close();
    }
}

// 输出内容
hello!
```

操作示例 2：利用内存流实现一个小写字母转大写字母的操作

```java
package com.example;

import java.io.ByteArrayInputStream;
import java.io.ByteArrayOutputStream;
import java.io.InputStream;
import java.io.OutputStream;

public class JavaAPIDemo {
    public static void main(String[] args) throws Exception {
        // 将数据保存到内存流,小写字母
        InputStream input = new ByteArrayInputStream("sanliu".getBytes());
        // 读取内存中的数据
        OutputStream output = new ByteArrayOutputStream();
        int data;
        // 每次读取一个字节
        while ((data = input.read()) != -1) {
            // 保存数据
            output.write(Character.toUpperCase((char) data));
        }
        System.out.println(output);
        input.close();
        output.close();
    }
}

// 输出内容
SANLIU
```

操作示例 3：如果不希望以字符串的形式返回，希望返回二进制的数据，那么此时就可以利用`ByteArrayOutputStream`子类的扩展功能获取全部字节数据

```java
package com.example;

import java.io.ByteArrayInputStream;
import java.io.ByteArrayOutputStream;
import java.io.InputStream;

public class JavaAPIDemo {
    public static void main(String[] args) throws Exception {
        // 将数据保存到内存流,小写字母
        InputStream input = new ByteArrayInputStream("sanliu".getBytes());
        // 必须使用子类来调用子类自己的扩展方法
        ByteArrayOutputStream output = new ByteArrayOutputStream();
        int data;
        // 每次读取一个字节
        while ((data = input.read()) != -1) {
            // 保存数据
            output.write(Character.toUpperCase((char) data));
        }
        // 获取全部数据
        byte result[] = output.toByteArray();
        System.out.println(new String(result));
        input.close();
        output.close();
    }
}
```

从JDK1.9后即便不知道以上方法的使用形式，也可以实现内容的全部输出，因为`InputStream`类中提供了`readAllBytes()`方法

> PS：字符数组和字符串内存操作流类似，自行研究。可参考：http://www.yiidian.com/java-io/



# 管道流【了解】

在之前学习的几种IO流中不难发现，它们在面对线程间通信问题的时候显然无法实现IO操作，管道流主要功能是实现两个线程之间的IO处理操作

```
OutputStreamWriter                                                      InputStreamReader
          ┌────────────────────────────────连接─────────────────────────────────┐
          ⬆                                管道                                 ⬇
发送信息线程对象(Runnable)       <------------------------------->       接收信息线程对象(Runnable)
```

对于管道流也分为两类：

1. 字节管道流：`PipedOutputStream`、`PipedInputStream`
   - 字节管道流的连接处理：`public void connect(PipedInputStream snk) throws IOException;`
2. 字符管道流：`PipedWriter`、`PipedReader`
   - 字符管道流连接处理：`public void connect(PipedReader snk) throws IOException;`

| 管道流类型        | 构造方法                                                   | 继承结构                                            |
| ----------------- | ---------------------------------------------------------- | --------------------------------------------------- |
| PipedOutputStream | PipedOutputStream(PipedInputStream snk) throws IOException | public class PipedOutputStream extends OutputStream |
| PipedInputStream  | PipedInputStream(PipedOutputStream src) throws IOException | public class PipedInputStream extends InputStream   |
| PipedWriter       | PipedWriter(PipedReader snk) throws IOException            | public class PipedWriter extends Writer             |
| PipedReader       | PipedReader(PipedWriter src) throws IOException            | public class PipedReader extends Reader             |

操作示例 1：

```java
package com.example;

import java.io.ByteArrayOutputStream;
import java.io.IOException;
import java.io.PipedInputStream;
import java.io.PipedOutputStream;

class SendThread implements Runnable {
    // 管道输出流
    private PipedOutputStream output = new PipedOutputStream();

    @Override
    public void run() {
        // 利用管道实现数据的发送处理
        try {
            this.output.write(("【信息发送 - " + Thread.currentThread().getName() + "】www.xxxx.cn\n").getBytes());
        } catch (IOException e) {
            e.printStackTrace();
        }
        try {
            this.output.close();
        } catch (IOException e) {
            e.printStackTrace();
        }
    }

    public PipedOutputStream getOutput() {
        return output;
    }
}

class ReceiveThread implements Runnable {
    // 管道输入流
    private PipedInputStream input = new PipedInputStream();

    @Override
    public void run() {
        byte[] data = new byte[1024];
        int len ;
        // 所有的数据保存到内存输出流
        ByteArrayOutputStream bos = new ByteArrayOutputStream();
        try {
            while ((len = input.read(data)) != -1) {
                // 所有的数据保存在内存流里面
                bos.write(data, 0, len);
            }
            System.out.println("{" + Thread.currentThread().getName() + "接收消息}\n" + new String(bos.toByteArray()));
            bos.close();
        } catch (IOException e) {
            e.printStackTrace();
        }
        try {
            this.input.close();
        } catch (IOException e) {
            e.printStackTrace();
        }
    }

    public PipedInputStream getInput() {
        return input;
    }
}

public class JavaAPIDemo {
    public static void main(String[] args) throws Exception {
        SendThread send = new SendThread();
        ReceiveThread receive = new ReceiveThread();
        send.getOutput().connect(receive.getInput()); // 进行管道连接
        new Thread(send, "消息发送线程").start();
        new Thread(receive, "消息接收线程").start();
    }
}

// 输出内容
{消息接收线程接收消息}
【信息发送 - 消息发送线程】www.xxxx.cn
```

操作示例 2：对示例1改造的简洁版

```java
package com.example;

import java.io.IOException;
import java.io.PipedInputStream;
import java.io.PipedOutputStream;

class SendThread implements Runnable {
    private PipedOutputStream output = new PipedOutputStream();

    @Override
    public void run() {
        try {
            this.output.write("中华人民共和国万岁!".getBytes());
        } catch (IOException e) {
            e.printStackTrace();
        }
    }

    public PipedOutputStream getOutput() {
        return output;
    }
}

class ReceiveThread implements Runnable {
    private PipedInputStream input = new PipedInputStream();

    @Override
    public void run() {
        byte[] data = new byte[1024];
        try {
            int len = this.input.read(data);
            System.out.println("接收数据：" + new String(data, 0, len));
        } catch (IOException e) {
            e.printStackTrace();
        }
    }
    public PipedInputStream getInput() {
        return input;
    }
}

public class JavaAPIDemo {
    public static void main(String[] args) throws Exception {
        SendThread send = new SendThread();
        ReceiveThread receive = new ReceiveThread();
        send.getOutput().connect(receive.getInput());
        new Thread(send).start();
        new Thread(receive).start();
    }
}

// 输出内容
接收数据：中华人民共和国万岁!
```

PS：发送线程通过`PipedOutputStream`类中的`connect()`方法与接收线程的`PipedInputStream`类进行连接，当发送线程通过管道输出流发送数据时，接收线程就可以通过线程输入流接收到内容。管道就类似于在医院打点滴的效果，一个负责发送，一个负责接收，中间靠一个管道连接。



# 装饰设计模式与打印流

## 装饰设计模式

如果要想通过程序实现内容的输出，核心的本质一定要依靠OutputStream类完成，但是OutputStream有一个很大的缺点：这个类的数据输出操作功能有限：public void write(byte[] b) throws IOException，所有的数据一定要转为字节数组后才能输出，假设现在项目里面可能输出的是long、double、Date，这种情况下就必须将这些数据变为字节的形式来处理，这样的处理一定是非常麻烦的，所以在开发之中最初的时候为了解决此类的重复操作，往往会由开发者自行定义一些功能类已简化输出过程。

操作示例 1：打印流设计思想

```java
package com.example;

import java.io.File;
import java.io.FileOutputStream;
import java.io.IOException;
import java.io.OutputStream;

/**
 * 实现一些常用数据的输出
 */
class PrintUtil implements AutoCloseable {
    //  不管现在如何进行输出操作，核心使用的就是OutputStream
    private OutputStream output;

    // 由外部来决定输出的位置
    public PrintUtil(OutputStream output) {
        this.output = output;
    }

    @Override
    public void close() throws Exception {
        this.output.close();
    }

    public void println(String str) {
        this.print(str + "\r\n");
    }

    public void print(long num) {
        this.print(String.valueOf(num));
    }

    public void println(long num) {
        this.println(String.valueOf(num));
    }

    // 输出字符串
    public void print(String str) {
        try {
            this.output.write(str.getBytes());
        } catch (IOException e) {
            e.printStackTrace();
        }
    }
}

public class JavaAPIDemo {
    public static void main(String[] args) throws Exception {
        File file = new File("D:" + File.separator + "test.txt");
        PrintUtil pu = new PrintUtil(new FileOutputStream(file));
        pu.println("姓名：小强子");
        pu.print("年龄：");
        pu.println(78);
        pu.close();
    }
}

// 输出内容
姓名：小强子
年龄：78
```

在整个操作过程之中打印流的设计思想的本质在于：提高已有类的功能，例如：OutputStream是唯一可实现输出的操作标准类，所以应该以其为核心根本，但是这个类的输出的操作功能有限，所以不方便进行输出各个数据类型，那么就为它做出了一层包装，所以此时采用的设计思想就是“装饰设计模式”。



## 打印流

为了弥补原始的`OutputStream`功能的不足，java.io包为开发者提供了打印流：`PrintStream`（字节打印流）和`PrintWriter`（字符打印流）

字节打印流`PrintStream`类的常用方法介绍

```java
public class PrintStream extends FilterOutputStream implements Appendable, Closeable {}
```

| 方法名                                                       | 类型 | 描述                                    |
| ------------------------------------------------------------ | ---- | --------------------------------------- |
| public PrintStream(File file)                                | 构造 | 通过一个File对象实例化PrintStream类     |
| public PrintStream(OutputStream out)                         | 构造 | 接收OutputStream对象实例化PrintStream类 |
| public PrintStream(String fileName)                          | 构造 | 接收指定文件名实例化PrintStream类       |
| public PrintStream printf(Locale l, String format, Object ... args) | 普通 | 根据指定Locale进行格式化输出            |
| public PrintStream printf(String format, Object ... args)    | 普通 | 根据本地环境格式化输出                  |
| public void print (数据类型 变量)                            | 普通 | 此方法被重载很多次，输出任意数据        |
| public void println (数据类型 变量)                          | 普通 | 此方法被重载很多次，输出任意数据后换行  |

字符打印流`PrintWriter`类的常用方法介绍

```java
public class PrintWriter extends Writer {}
```

| 方法名                                                       | 类型 | 描述                                    |
| ------------------------------------------------------------ | ---- | --------------------------------------- |
| public PrintWriter(File file) throws FileNotFoundException   | 构造 | 通过一个File对象实例化PrintWriter类     |
| public PrintWriter(OutputStream out)                         | 构造 | 接收OutputStream对象实例化PrintWriter类 |
| public PrintWriter (Writer out)                              | 构造 | 接收Writer 对象实例化PrintWriter类      |
| public PrintWriter printf(Locale l, String format, Object ... args) | 普通 | 根据指定Locale进行格式化输出            |
| public PrintWriter printf(String format, Object ... args)    | 普通 | 根据本地环境格式化输出                  |
| public void print (数据类型 变量)                            | 普通 | 此方法被重载很多次，输出任意数据        |
| public void println (数据类型 变量)                          | 普通 | 此方法被重载很多次，输出任意数据后换行  |



下面使用`PrintWriter`类来实现数据的输出操作。

操作示例 1：数据输出

```java
package com.example;

import java.io.File;
import java.io.FileOutputStream;
import java.io.PrintWriter;

public class JavaAPIDemo {
    public static void main(String[] args) throws Exception {
        File file = new File("d:" + File.separator + "test.txt");
        PrintWriter pu = new PrintWriter(new FileOutputStream(file));
        pu.println("姓名：小强子");
        pu.print("年龄：");
        pu.print(78);
        pu.close();
    }
}

// 输出内容
姓名：小强子
年龄：78
```

从JDK1.5开始打印流支持了格式化输出操作，可以利用print()方法设置数据的占位符（字符串：%s、整数：%d、浮点数：%m.nf、字符：%c 等）与具体的数值结合后进行内容输出。

操作示例 2：格式化输出

```java
package com.example;

import java.io.File;
import java.io.FileOutputStream;
import java.io.PrintWriter;

public class JavaAPIDemo {
    public static void main(String[] args) throws Exception {
        File file = new File("d:" + File.separator + "test.txt");
        PrintWriter pu = new PrintWriter(new FileOutputStream(file));
        String name = "小强子子";
        int age = 78;
        double salary = 72823.6323113;
        pu.printf("姓名：%s、年龄：%d、月收入：%9.2f", name, age, salary);
        pu.close();
    }
}

// 输出内容
姓名：小强子子、年龄：78、月收入： 72823.63
```

比起直接使用OutputStream类，那么使用PrintWriter、PrintStream类的处理操作会更加简单。以后只要是程序进行内容输出的时候全部使用打印流。



# System类对标准IO支持

System类是一个系统类，而且是一个从头到尾一直都在使用的系统类，而在这个系统类之中提供有三个常量：

| 常量                                | 类型 | 描述               |
| ----------------------------------- | ---- | ------------------ |
| public static final PrintStream err | 常量 | 错误输出           |
| public static final PrintStream out | 常量 | 标准输出（显示器） |
| public static final InputStream in  | 常量 | 标准输入（键盘）   |

可以发现`System`类中3个常量有两个都是`PrintStream`类的示例，所以之前一直使用的`System.out.println()`操作实际上就是利用IO操作完成的输出。

> 历史遗留问题：`System`类由于出现比较早，存在命名不标准问题，可以发现：out、err、in 这3个全局常量名称全是不小写字母

操作示例 1：通过`System.out`为`OutputStream`实例化

```java
package com.example;
import java.io.OutputStream;
public class JavaAPIDemo {
    public static void main(String[] args) throws Exception {
        OutputStream outputStream = System.out;
        outputStream.write("www.xxxx.cn".getBytes());
        outputStream.write("\t\n".getBytes());
        outputStream.write("我们都是中国人".getBytes());
    }
}

// 输出内容

```

操作示例 2：观察输出

```java
package com.example;
public class JavaAPIDemo {
    public static void main(String[] args) throws Exception {
        try {
            Integer.parseInt("a");
        } catch (Exception e) {
            // 黑色信息：java.lang.NumberFormatException: For input string: "a"
            System.out.println(e);
            // 红色信息：java.lang.NumberFormatException: For input string: "a"
            System.err.println(e);
        }
    }
}
```

`System.out`和`System.err`都是同一种类型的，如果现在使用的是IDE则在使用`System.err`输出的时候会使用红色字体，`System.out`会使用黑色字体。

最早设置两个输出的操作的目的：`System.out`是输出那些希望用户可以看见的信息，`System.err`是输出那些不希望用户看见的信息，如果有需要也可以修改输出的位置：

1. 修改out的输出位置：`public static void setOut(PrintStream out);`
2. 修改err的输出位置 ：`public static void setErr(PrintStream err);`

操作示例 3：修改`System.err`位置

```java
package com.example;

import java.io.FileOutputStream;
import java.io.PrintStream;

public class JavaAPIDemo {
    public static void main(String[] args) throws Exception {
        //System.setErr(new PrintStream("D:\\test-err.txt")); // 两种PrintStream实例化方式都可以
        System.setErr(new PrintStream(new FileOutputStream("D:\\test-err.txt")));
        try {
            Integer.valueOf("a");
        } catch (Exception e) {
            System.out.println(e);
            System.err.println(e);// 输出到文件里了
        }
    }
}
// 输出内容（如下内容输出到文件中）
java.lang.NumberFormatException: For input string: "a"
```

在System类里面还提供有一个in的常量，而这个常量对应的是标准输入设备键盘的输入处理，可以实现键盘数据输入

操作示例 3：实现键盘输入

```java
package com.example;

import java.io.InputStream;

public class JavaAPIDemo {
    public static void main(String[] args) throws Exception {
        // 此时的输入流为键盘输入
        InputStream input = System.in;
        System.out.print("请输入信息：");
        byte[] data = new byte[1024];
        int len = input.read(data);
        System.out.println("输入内容为：" + new String(data, 0, len));
    }
}

// 请输入信息：
www.xxxx.cn
// 输入内容为：
www.xxxx.cn
```

但是这样的键盘输入处理本身是有缺陷的：

1. 数据开辟的空间不足，那么对于数据将无法一次性的进行读取操作，所以就需要进行重复读取
2. 如果处理不当，则在进行中文操作的时候会存在乱码（文字的编码被切割）

# 缓冲流【掌握】

## 缓冲流概述

> 1、首先抛出一个问题，有了`InputStream`为什么还要有`BufferedInputStream`?
>
> `BufferedInputStream`和`BufferedOutputStream`这两个类分别是`FilterInputStream`和`FilterOutputStream`的子类，作为装饰器子类，使用它们可以防止每次读取/发送数据时进行实际的写操作，代表着使用缓冲区。
>
> 我们有必要知道不带缓冲的操作，每读一个字节就要写入一个字节，由于涉及磁盘的IO操作相比内存的操作要慢很多，所以不带缓冲的流效率很低。带缓冲的流，可以一次读很多字节，但不向磁盘中写入，只是先放到内存里。等凑够了缓冲区大小的时候一次性写入磁盘，这种方式可以减少磁盘操作次数，速度就会提高很多！
>
> 同时正因为它们实现了缓冲功能，所以要注意在使用`BufferedOutputStream`写完数据后，要调用`flush()`方法或`close()`方法，强行将缓冲区中的数据写出。否则可能无法写出数据。与之相似还`BufferedReader`和`BufferedWriter`两个类。
>
> 2、现在就可以回答在本文的开头提出的问题：`BufferedInputStream`、`BufferedOutputStream`类就是实现了缓冲功能的输入输出流。使用带缓冲的输入输出流，效率更高，速度更快。
>
> 总结：
>
> 1. `BufferedInputStream`是缓冲输入流。它继承于`FilterInputStream`。
>
> 2. `BufferedInputStream`的作用是为另一个输入流添加一些功能，例如，提供“缓冲功能”以及支持`mark()`标记和`reset()`重置方法。
>
> `BufferedInputStream`本质上是通过一个内部缓冲区数组实现的。例如，在新建某输入流对应的BufferedInputStream后，当我们通过read()读取输入流的数据时，BufferedInputStream会将该输入流的数据分批的填入到缓冲区中。每当缓冲区中的数据被读完之后，输入流会再次填充数据缓冲区；如此反复，直到我们读完输入流数据位置。

缓冲流：也叫高效流，是对4个`FileXxx` 流的“增强流”

缓冲流的基本原理：

1. 使用了底层流对象从具体设备上获取数据，并将数据存储到缓冲区的数组内
2. 通过缓冲区的`read()`方法从缓冲区获取具体的字符数据，这样就提高了效率
3. 如果用`read()`读取字符数据，并存储到另一个容器中，直到读取到了换行符时，将另一个容器临时存储的数据转成字符串返回，就形成了`readLine()`功能

也就是说在创建流对象时，会创建一个内置的默认大小的缓冲区数组，通过缓冲区读写，减少系统IO次数，从而提高读写的效率。缓冲流按照数据类型分类：

1. 字节缓冲流：`BufferedInputStream`、`BufferedOutputStream`
2. 字符缓冲流：`BufferedReader`、`BufferedWriter`



## 字节缓冲流

字节缓冲流分为2种：

1. 字节缓冲输入流：BufferedInputStream
2. 字节缓冲输出流：BufferedOutputStream

> 字节缓冲输入流：BufferedInputStream

```java
publicclass BufferedInputStream extends FilterInputStream {}
```

| 方法名                                        | 类型 | 描述                                                        |
| --------------------------------------------- | ---- | ----------------------------------------------------------- |
| BufferedInputStream(InputStream in)           | 构造 | 使用默认buf大小、底层字节输入流构建bis                      |
| BufferedInputStream(InputStream in, int size) | 构造 | 使用指定buf大小、底层字节输入流构建bis                      |
| int available()                               | 普通 | 返回底层流对应的源中有效可供读取的字节数                    |
| int read()                                    | 普通 | 读取buf中下一个字节                                         |
| int read(byte[] b, int off, int len)          | 普通 | 读取buf中下一个字节len长度                                  |
| long skip(long n)                             | 普通 | 跳过n个字节、 不仅仅是buf中的有效字节、也包括in的源中的字节 |
| boolean markSupport()                         | 普通 | 查看此流是否支持mark                                        |
| void mark(int readLimit)                      | 普通 | 标记当前buf中读取下一个字节的下标                           |
| void reset()                                  | 普通 | 重置最后一次调用mark标记的buf中的位置                       |
| void close()                                  | 普通 | 关闭此流、释放与此流有关的所有资源                          |

源码关键字段分析：

```java
// 内置缓存字节数组的大小 8KB
private static int defaultBufferSize = 8192;

// 内置缓存字节数组
protected volatile byte buf[];

// 当前buf中的字节总数、注意不是底层字节输入流的源中字节总数
protected int count;

// 当前buf中下一个被读取的字节下标
protected int pos;

// 最后一次调用mark(int readLimit)方法记录的buf中下一个被读取的字节的位置
protected int markpos = -1;

// 调用mark后、在后续调用reset()方法失败之前云寻的从in中读取的最大数据量、用于限制被标记后buffer的最大值
protected int marklimit;    
```

> 字节缓冲输出流：BufferedOutputStream

```java
public class BufferedOutputStream extends FilterOutputStream {}
```

| 方法名                                           | 类型 | 描述                                                         |
| ------------------------------------------------ | ---- | ------------------------------------------------------------ |
| BufferedOutputStream(OutputStream out)           | 构造 | 使用默认大小、底层字节输出流构造bos。默认缓冲大小是8192字节(8KB),可看源码 |
| BufferedOutputStream(OutputStream out, int size) | 构造 | 使用指定大小、底层字节输出流构造bos                          |
| write(byte b)                                    | 普通 | 将一个字节写入到buf中                                        |
| write(byte[] b, int off, int len)                | 普通 | 将b的一部分写入buf中                                         |
| void  flush()                                    | 普通 | 将写入bos中的数据flush到out指定的目的地中、<br />注意这里不是flush到out中、因为其内部又调用了out.flush() |
| void close()                                     | 普通 | 关闭释放资源,BufferedOutputStream在close()时会⾃动flush，close为父类的方法 |

> 温馨提示：`BufferedOutputStream`没有自己的`close()`方法，当它调用父类`FilterOutputStrem`的关闭方法时，会间接调用自己实现的`flush()`方法将buf中残存的字节`flush()`到out中，再out.flush()到目的地中，`DataOutputStream`也是如此。 
>
> 注意点：
>
> 1. `BufferedOutputStream`在`close()`时会自动`flush()`
> 2. `BufferedOutputStream`在不调用`close()`情况下缓冲区不满，又需要把缓冲区的内容写入到文件或其他地方时，需手动调用`flush()`
>



操作示例 1：拷贝文件（手动关闭流）

```java
package com.example;
import java.io.*;

public class JavaAPIDemo {
    public static void main(String[] args) {
        try {
            BufferedInputStream bis = new BufferedInputStream(new FileInputStream("D:\\test.txt"));
            BufferedOutputStream bos = new BufferedOutputStream(new FileOutputStream("D:\\test-copy.txt"));
            byte[] buf = new byte[1024];
            int len;
            while ((len = bis.read(buf)) != -1) {
                bos.write(buf, 0, len);
            }
            // 刷新此缓冲的输出流，才可以保证数据全部输出完成,close会⾃动关闭
            bos.flush();
            // 关闭的时候只需要关闭最外层的流就⾏了，源码⾥⾯会⾃动关闭inputstream对象的
            bis.close();
            bos.close();
        } catch (Exception e) {
            e.printStackTrace();
        }
    }
}
```

操作示例 2：拷贝文件（JDK1.7自动关闭资源）

```java
package com.example;
import java.io.*;

public class JavaAPIDemo {
    public static void main(String[] args) {
        try (BufferedInputStream bis = new BufferedInputStream(new FileInputStream("D:\\test.txt"));
             BufferedOutputStream bos = new BufferedOutputStream(new FileOutputStream("D:\\test-copy.txt"))) {
            int size;
            byte[] buf = new byte[1024];
            while ((size = bis.read(buf)) != -1) {
                bos.write(buf, 0, size);
            }
        } catch (Exception e) {
            e.printStackTrace();
        }
    }
}
```





## 字符缓冲流

字符缓冲流分为2种：

1. 字符缓冲输入流：BufferedReader
2. 字符缓冲输出流：BufferedWriter

> 字符缓冲输入流：BufferedReader

```java
public class BufferedReader extends Reader {}
```

| 方法名                                   | 类型 | 描述                                                         |
| ---------------------------------------- | ---- | ------------------------------------------------------------ |
| BufferedReader(Reader in)                | 构造 | 创建一个使用默认大小输入缓冲区的缓冲字符输入流               |
| BufferedReader(Reader in, int size)      | 构造 | 创建一个使用指定大小输入缓冲区的缓冲字符输入流               |
| int  read()                              | 普通 | 读取单个字                                                   |
| int  read(char[] cbuf, int off, int len) | 普通 | 将字符读入数组的某一部分                                     |
| String  readLine()                       | 普通 | 读取一个文本行（1次性从缓冲区把内容全部读出来，读到最后返回null） |
| long  skip(long n)                       | 普通 | 跳过字符                                                     |
| boolean  ready()                         | 普通 | 判断此流是否已准备好被读取                                   |
| void  mark(int readAheadLimit)           | 普通 | 标记流中的当前位置                                           |
| boolean  markSupported()                 | 普通 | 判断此流是否支持 mark() 操作（它一定支持）                   |
| void  reset()                            | 普通 | 将流重置到最新的标记                                         |
| void  close()                            | 普通 | 关闭该流并释放与之关联的所有资源                             |

> 字符缓冲输出流：BufferedWriter

```java
public class BufferedWriter extends Writer {}
```

| 方法名                                     | 类型 | 描述                                             |
| ------------------------------------------ | ---- | ------------------------------------------------ |
| BufferedWriter(Writer out)                 | 构造 | 创建一个使用默认大小输出缓冲区的缓冲字符输出流   |
| BufferedWriter(Writer out, int size)       | 构造 | 创建一个使用给定大小输出缓冲区的新缓冲字符输出流 |
| void  write(int c)                         | 普通 | 写入单个字符                                     |
| void  write(char[] cbuf, int off, int len) | 普通 | 写入字符数组的某一部分                           |
| void  write(String s, int off, int len)    | 普通 | 写入字符串的某一部分                             |
| void  newLine()                            | 普通 | 写入一个行分隔符，由系统属性定义符号             |
| void  flush()                              | 普通 | 刷新该流的缓冲                                   |
| void  close()                              | 普通 | 关闭此流，但要先刷新它                           |

操作示例 1：拷贝文件（JDK1.7以后自动关闭流方式）

```java
package com.example;
import java.io.*;

public class JavaAPIDemo {
    public static void main(String[] args) {
        File file1 = new File("D:\\test.txt");
        File file2 = new File("D:\\test-copy.txt");
        copyFile(file1, file2);
    }

    private static void copyFile(File oldFile, File newFile) {
        try (BufferedReader bufferedReader = new BufferedReader(new FileReader(oldFile));
             BufferedWriter bufferedWriter = new BufferedWriter(new FileWriter(newFile))) {

            String len;
            // 每次读取一行的内容
            while ((len = bufferedReader.readLine()) != null) {
                // 把内容写入文件
                bufferedWriter.write(len);
                // 换行，len 是一行数据，所以每写一行就要换行
                bufferedWriter.newLine();
            }
            // 强制把数组内容写入文件，其实也可以不写该方法
            bufferedWriter.flush();
        } catch (IOException e) {
            e.printStackTrace();
        }
    }
}
```

操作示例 2：实现键盘数据输入

```java
package com.example;

import java.io.BufferedReader;
import java.io.InputStreamReader;

public class JavaAPIDemo {
    public static void main(String[] args) throws Exception {
        BufferedReader input = new BufferedReader(new InputStreamReader(System.in));
        System.out.print("请输入信息：");
        // 接收输入信息
        String msg = input.readLine();
        System.out.println("输入内容为：" + msg);
        input.close();
    }
}

// 输出内容
请输入信息：马上就放假了，我们要一起开心的学习，不放假了！
输入内容为：马上就放假了，我们要一起开心的学习，不放假了！
```

操作示例 3：接收整型输入并且验证

```java
package com.example;

import java.io.BufferedReader;
import java.io.InputStreamReader;

public class JavaAPIDemo {
    public static void main(String[] args) throws Exception {
        BufferedReader input = new BufferedReader(new InputStreamReader(System.in));
        System.out.print("请输入您的年龄：");
        // 接收输入信息
        String msg = input.readLine();
        // 是否由数字所组成
        if (msg.matches("\\d{1,3}")) {
            int age = Integer.parseInt(msg);
            System.out.println("年龄为：" + age);
        } else {
            System.err.println("请确保您看懂了我的提示，不要随意输入，伤不起！");
        }
    }
}

// 输出内容
请输入您的年龄：xx
请确保您看懂了我的提示，不要随意输入，伤不起！
```

`BufferedReader`类最大的特点就是可以利用`readLine()`一次性读取多个字节的数据，并将这些数据转为字符串接收，这样就可以通过正则判断，或想各个数据类型进行转换处理

# Scanner输入流工具

`Scanner`类是JDK1.5以后出现的用于解决输入流处理问题的程序类，在整体设计上优于之前版本的`BufferedReader`类，其主要的目的解决输入流的访问问题的，可以理解为`BufferedReader`的替代功能类，在`Scanner`类里面有如下几种操作方法：

| 方法名                                      | 类型 | 描述                                           |
| ------------------------------------------- | ---- | ---------------------------------------------- |
| public Scanner(File source)                 | 构造 | 从文件中接收内容                               |
| public Scanner(InputStream source)          | 构造 | 从指定的字节输入流种接收内容                   |
| public boolean hasNext()                    | 普通 | 如果此扫描器有另一个标记在其输入此方法返回true |
| public boolean hasNext(Pattern pattern)     | 普通 | 判断输入的数据是否符合指定的正则规则           |
| public boolean hasNextXxx()                 | 普通 | 判断数据内容是否为指定类型，如hasNextInt()     |
| public String next()                        | 普通 | 接收内容                                       |
| public String next(Pattern pattern)         | 普通 | 接收内容，进行正则验证                         |
| public 数据类型 nextXxx()                   | 普通 | 接收指定类型的数据，如nextInt()                |
| public float nextFloat()                    | 普通 | 接收小数                                       |
| public Scanner useDelimiter(String pattern) | 普通 | 设置读取的分隔符                               |

操作示例 1：使用Scanner实现键盘数据输入

```java
package com.example;

import java.util.Scanner;

public class JavaAPIDemo {
    public static void main(String[] args) throws Exception {
        Scanner scan = new Scanner(System.in);
        System.out.print("请输入年龄：");
        // 判断是否有整数输入
        if (scan.hasNextInt()) {
            // 直接获取数字
            int age = scan.nextInt();
            System.out.println("您的年龄：" + age);
        } else {
            System.out.println("输入的不是数字，程序无法正常执行！");
        }

        // 判断是否有内容输入
        if (scan.hasNext()) {
            String msg = scan.next();
            System.out.println("输入信息为：" + msg);
        }
        scan.close();
    }
}

// 输出内容
请输入年龄：中国
输入的不是数字，程序无法正常执行！
输入信息为：中国
```

使用Scanner输入数据还有一个最大的的特点是可以直接利用正则进行验证判断

操作示例 2：输入日期并使用正则判断（yyyy-MM-dd）

```java
package com.example;

import java.text.SimpleDateFormat;
import java.util.Scanner;

public class JavaAPIDemo {
    public static void main(String[] args) throws Exception {
        Scanner scan = new Scanner(System.in);
        System.out.print("请输入您的生日：");
        if (scan.hasNext("\\d{4}-\\d{2}-\\d{2}")) {
            String str = scan.next("\\d{4}-\\d{2}-\\d{2}");
            System.out.println("输入信息为：" + new SimpleDateFormat("yyyy-MM-dd").parse(str));
        }
        scan.close();
    }
}

// 输出内容
请输入您的生日：1994-04-08
输入信息为：Fri Apr 08 00:00:00 CST 1994
```

现在可以发现Scanner的整体设计要好于BufferedReader，而且要比直接使用InputStream类读取要方便。例如，现在如果要读取一个文本文件中的所有内容信息，如果采用的是InputStream类，那么就必须依靠内存输出流，进行临时数据的保存，之后还需要判断读取的内容是否是换行。

操作示例 3：读取文件内容

```java
package com.example;

import java.io.File;
import java.util.Scanner;

public class JavaAPIDemo {
    public static void main(String[] args) throws Exception {
        Scanner scan = new Scanner(new File("D:\\test.txt"));
        // 设置读取分隔符
        scan.useDelimiter("\n");
        while (scan.hasNext()) {
            System.out.println(scan.next());
        }
        scan.close();
    }
}
```

在以后的开发过程之中，如果程序需要输出数据一定使用打印流，输入数据使用Scanner（BufferedReader）



# 对象流和数据流

## 对象序列化

### 1、对象序列化基本概念

所谓的对象序列化指的是将内存中保存的对象以二进制数据流的形式进行处理，可以实现对象的保存或者是网络传输。

然而并不是所有的对象都可以被序列化，在`Java`中有一个强制性要求：如果要序列化对象，那么对象所在类一定要实现`java.io.Serializable`父接口，作为序列化的标记，这个接口并没有实现任何的方法，因为它描述的是一种类的能力。

操作示例 1：定义一个可以被序列化的类

```java
@SuppressWarnings("serial")
class Person implements Serializable {	// Person类可以被序列化 
	private String name ;
	private int age ;
	public Person(String name,int age) {
		this.name = name ;
		this.age = age ;
	}
	// setter、getter略
	@Override
	public String toString() {
		return "姓名：" + this.name + "、年龄：" + this.age ;
	}
}
```

此时`Person`类产生了每一个对象都可以实现二进制数据传输，属于可以被序列化的程序类



### 2、序列化与反序列化处理

有了序列化的支持类后，如果想要实现序列化和反序列化操作则可以利用以下两个类完成。

序列化：ObjectOutputStream：

```java
// 类定义
public class ObjectOutputStream extends OutputStream implements ObjectOutput, ObjectStreamConstans {}
// 构造方法
public ObjectOutputStream(OutputStream out) throws IOException;
// 成员方法
public final void writeObject(Object obj) throws IOException;
```

反序列化：ObjectInputStream：

```java
// 类定义
public class ObjectInputStream extends InputStream implements ObjectInput, ObjectStreamConstants {}
// 构造方法
public ObjectInputStream(InputStream in) throws IOException;
// 成员方法
public final Object readObject() throws IOException, ClassNotFoundException;
```

操作示例 1：实现序列化与反序列化

```java
package com.example;

import java.io.File;
import java.io.FileInputStream;
import java.io.FileOutputStream;
import java.io.ObjectInputStream;
import java.io.ObjectOutputStream;
import java.io.Serializable;

@SuppressWarnings("serial")
class Person implements Serializable {    // Person类可以被序列化
    private String name;
    private int age;

    public Person(String name, int age) {
        this.name = name;
        this.age = age;
    }

    // setter、getter略
    @Override
    public String toString() {
        return "姓名：" + this.name + "、年龄：" + this.age;
    }
}

public class JavaAPIDemo {
    private static final File SAVE_FILE = new File("D:" + File.separator + "test.person");
    
    public static void main(String[] args) throws Exception {
        // 序列化
        saveObject(new Person("小喷嚏", 78));
        // 反序列化
        System.out.println(loadObject());
    }

    public static void saveObject(Object obj) throws Exception {
        ObjectOutputStream oos = new ObjectOutputStream(new FileOutputStream(SAVE_FILE));
        // 序列化
        oos.writeObject(obj);
        oos.close();
    }

    public static Object loadObject() throws Exception {
        ObjectInputStream ois = new ObjectInputStream(new FileInputStream(SAVE_FILE));
        // 反序列化
        Object obj = ois.readObject();
        ois.close();
        return obj;
    }
}

// 执行内容
姓名：小喷嚏、年龄：78
```

在Java中的对象序列化与反序列化必须使用内部提供的对象操作流，因为这里面牵扯到了二进制数据的格式，所以不能自定义处理，另外如果要想实现一组对象的序列化，则可以使用对象数组完成。

在很多的实际项目开发过程之中，开发者很少能见到ObjectOutputStream、ObjectInputStream类的直接操作，因为会有一些容器帮助开发者自动实现。

> 另外，当JVM反序列化对象时，能找到class文件，但是class文件在序列化对象之后发生了修改，那么反序列化操作也会失败，抛出一个`InvalidClassException`异常。发生这个异常的原因如下：
>
> 1. 该类的序列版本号与从流中读取的类描述符的版本号不匹配
> 2. 该类包含未知数据类型
> 3. 该类没有可访问的无参数构造方法
>
> `Serializable` 接口给需要序列化的类，提供了一个序列版本号。`serialVersionUID` 该版本号的目的在于验证序列化的对象和对应类是否版本匹配。
>
> ```java
> // 加入序列版本号
> private static final long serialVersionUID = 1L;
> ```



### 3、Transient关键字

默认情况下当执行了对象序列化的时候会将类中的全部属性内容进行全部的序列化操作，但是很多情况下有一些属性可能并不需要进行序列化的处理，这个时候可以在属性定义中使用`transient`关键字来完成。transient关键字是类似于static、final等关键字的修饰符，它可以使类中的属性在序列化时跳过该属性。

```java
private transient String name;
```

在进行序列处理的时候name属性的内容是不会被保存下来的，换言之，读取的数据name将是其对应数据类型的默认值”null“。



## 数据流

为了方便地操作Java语言的基本数据类型和String的数据，可以使用数据流。

数据流有两个类 (用于读取和写出基本数据类型、 String类的数据）：DataInputStream和DataOutputStream。分别为InputStream和OutputStream子类

`DataInputStream`类的定义和方法

```java
public class DataInputStream extends FilterInputStream implements DataInput {}
```

| 方法名                                 | 类型 | 描述                                                         |
| -------------------------------------- | ---- | ------------------------------------------------------------ |
| public DataInputStream(InputStream in) | 构造 | 创建一个DataInputStream对象，参数为InputStream               |
| boolean readBoolean()                  | 普通 | 用于读取一个输入字节，如果字节不为零，则返回true，如果字节为零，则返回false |
| byte readByte()                        | 普通 | 用于读取和返回一个输入字节                                   |
| char readChar()                        | 普通 | 用于读取两个输入字节并返回一个char值                         |
| float readFloat()                      | 普通 | 用于读取四个输入字节并返回一个浮点值                         |
| double readDouble()                    | 普通 | 用于读取八个输入字节并返回一个双精度值                       |
| short readShort()                      | 普通 | 用于读取两个输入字节并返回一个short值                        |
| long readLong()                        | 普通 | 用于读取八个输入字节，并返回一个long值                       |
| int readInt()                          | 普通 | 用于读取输入字节并返回int值                                  |
| String readUTF()                       | 普通 | 用于读取使用UTF-8格式编码的字符串                            |
| void readFully(byte[] b)               | 普通 | 用于从输入流中读取字节并将其存储到缓冲区数组中               |

`DataOutputStream`类的定义和方法

```java
public class DataOutputStream extends FilterOutputStream implements DataOutput {}
```

| 方法名                                    | 类型 | 描述                                              |
| ----------------------------------------- | ---- | ------------------------------------------------- |
| public DataOutputStream(OutputStream out) | 构造 | 创建一个DataOutputStream对象，参数为OutputStream  |
| int size()                                | 普通 | 用于返回写入数据输出流的字节数                    |
| void write(int b)                         | 普通 | 用于将指定的字节写入基础输出流                    |
| void write(byte[] b, int off, int len)    | 普通 | 用于将len个数据字节写入输出流                     |
| void writeBoolean()                       | 普通 | 用于将布尔值作为1个字节的值写入输出流             |
| void writeByte(int v)                     | 普通 | 用于将字节作为1个字节的值写入输出流。             |
| void writeBytes(String s)                 | 普通 | 用于将字节作为字节序列写入输出流                  |
| void writeChar(int v)                     | 普通 | 用于将char作为2个字节的值写入输出流               |
| void writeChars(String s)                 | 普通 | 用于将字符串作为字符序列写入输出流                |
| void writeFloat(long v)                   | 普通 | 用于向输出流写入一个float                         |
| void writeDouble(double v)                | 普通 | 用于向输出流写入一个double                        |
| void writeShort(int v)                    | 普通 | 用于向输出流写入short                             |
| void writeLong(long v)                    | 普通 | 用于向输出流写入long                              |
| void writeInt(int v)                      | 普通 | 用于将int写入输出流                               |
| void writeUTF(String str)                 | 普通 | 用于以可移植的方式使用UTF-8编码将字符串写入输出流 |
| void flush()                              | 普通 | 用于刷新数据输出流                                |

操作示例 1：

```java
package com.example;

import java.io.*;

/**
 * 将内存中的字符串、基本数据类型的变量写出到文件中
 * 并将文件中存储的基本数据类型变量和字符串读取到内存中，保存在变量中
 */
public class JavaAPIDemo {
    public static void main(String[] args) throws Exception {
        // 写入操作
        DataOutputStream dos = new DataOutputStream(new FileOutputStream("D:\\data.dat"));
        // 写入UFF编码的字符串
        dos.writeUTF("小强");
        // 刷新操作，将内存中的数据写入文件
        dos.flush();
        dos.writeInt(23);
        dos.flush();
        dos.writeBoolean(true);
        dos.flush();
        // 会乱码，但是再次读的时候会恢复
        dos.close();

        // 读操作
        System.out.println("开始读操作了");
        DataInputStream dis = new DataInputStream(new FileInputStream("D:\\data.dat"));
        String name = dis.readUTF();
        int age = dis.readInt();
        boolean isMale = dis.readBoolean();
        System.out.println("name = " + name);
        System.out.println("age = " + age);
        System.out.println("isMale = " + isMale);
        dis.close();
    }
}

// 输出内容
开始读操作了
name = 小强
age = 23
isMale = true
```



# 随机流：RandomAccessFile

> java多线程之断点续传：https://www.bilibili.com/video/BV1ab4y1v79m

对于文件内容的处理操作主要是通过InputStream（Reader）、OutputStream（Writer）来实现，但是利用这些类实现的内容读取，只能够将数据部分部分读取进来，如果说现在有这样一种要求。

现在有一个非常庞大的文件，这个文件的内容大小有20G，如果此时按照传统的IO操作进行读取和分析根本就不可能完成，所以这种情况下在`java.io`包中有一个`RandomAccessFile`类，这个类可以实现文件的跳跃式的读取，可以只读取中间的部分内容（前提：需要有一个完善的保存形式），数据的保存位数要确定好。

`RandomAccessFile`类是用于读取和写入随机访问文件。随机访问文件的行为类似于大字节数组。有一个指向该数组的游标，称为**文件指针**，通过移动游标我们可以执行读写操作。如果在读取所需的字节数之前到达文件末尾，则抛出EOFException异常，它是IOException异常的一种。

`RandomAccessFile`类里面定义有如下的操作方法：

| 方法名                                     | 描述                                                         |
| ------------------------------------------ | ------------------------------------------------------------ |
| RandomAccessFile(File file, String mode)   | 创建RandomAccessFile, 以读取和可选地写入File参数指定的文件（处理模式：r、rw） |
| RandomAccessFile(String name, String mode) | 创建RandomAccessFile, 以读取具有指定名称的文件,也可以选择写入该文件（处理模式：r、rw） |
| void close()                               | 此方法关闭此随机存取文件流并释放与该流关联的所有系统资源     |
| int read()                                 | 此方法读取数据从该文件一个字节                               |
| int read(byte[] b)                         | 此方法读取为从该文件b.length个数据字节为字节数组             |
| int read(byte[] b, int off, int len)       | 此方法读取为从该文件len个字节数据到一个字节数组              |
| byte readByte()                            | 读取一个字节（8位）                                          |
| char readChar()                            | 此方法从文件读取一个字符                                     |
| double readDouble()                        | 此方法从文件读取一个double数                                 |
| float readFloat()                          | 此方法从文件读取一个浮点数                                   |
| int readInt()                              | 此方法从该文件中读取一个有符号的32位整数                     |
| String readLine()                          | 此方法从该文件中读取文本的下一行                             |
| long readLong()                            | 此方法从该文件中读取一个有符号的64位整数                     |
| short readShort()                          | 此方法从该文件中读取一个有符号的16位数                       |
| String readUTF()                           | 从这个文件中的字符串此方法读取                               |
| void write(byte[] b)                       | 此方法写入b.length个字节从指定的字节数组到该文件，并从当前文件指针 |
| void write(byte[] b, int off, int len)     | 此方法从指定的字节数组开始到该文件偏移量off写入len字节       |
| void write(int b)                          | 此方法写入指定的字节写入此文件                               |
| void writeByte(int v)                      | 此方法写入一个字节到文件作为一个单字节值                     |
| void writeBytes(String s)                  | 此方法写入字符串到文件为一个字节序列                         |
| void writeInt(int v)                       | 此方法写入一个int到文件为四个字节，高字节在前                |
| void writeLong(long v)                     | 此方法写入一个长的文件作为八个字节，高字节在前               |
| void writeShort(int v)                     | 此方法写入一个短的文件为两个字节，高字节在前                 |
| void writeUTF(String str)                  | 这种方法将一个字符串写入使用经修订的UTF-8编码以与机器无关的方式的文件 |
| int skinpByte(int n)                       | 指针跳过多少字节（重点）                                     |

操作示例 1：实现文件的保存

```java
package com.example;

import java.io.File;
import java.io.RandomAccessFile;

public class JavaAPIDemo {
    public static void main(String[] args) throws Exception {
        // 定义操作文件
        File file = new File("d:" + File.separator + "out.txt");
        // 读写模式
        RandomAccessFile raf = new RandomAccessFile(file, "rw");
        String[] names = new String[]{"zhangsan", "wangwu  ", "lisi    "};
        int[] ages = new int[]{30, 20, 16};
        for (int x = 0; x < names.length; x++) {
            // 写入字符串
            raf.write(names[x].getBytes());
            raf.writeInt(ages[x]);
        }
        raf.close();
    }
}
```

---

`RandomAccessFile`最大的特点是在于数据的读取处理上，因为所有的数据是按照固定的长度进行保存的，所以读取时就可以进行跳字节读取：

1. 向下跳：public int skipBytes(int n) throws IOException
2. 向回跳：public void seek(long pos) throws IOException

操作示例 2：读取数据

```java
package com.example;

import java.io.File;
import java.io.RandomAccessFile;

public class JavaAPIDemo {
    public static void main(String[] args) throws Exception {
        // 定义操作文件
        File file = new File("d:" + File.separator + "mldn.txt");
        // 读写模式
        RandomAccessFile raf = new RandomAccessFile(file, "rw");

        {
            // 读取"lisi"数据，跳过24位
            raf.skipBytes(24);
            byte[] data = new byte[8];
            int len = raf.read(data);
            // 姓名：lisi    、年龄：16
            System.out.println("姓名：" + new String(data, 0, len).trim() + "、年龄：" + raf.readInt());
        }

        {
            // 读取"wangwu"数据，回跳到12位
            raf.seek(12);
            byte[] data = new byte[8];
            int len = raf.read(data);
            // 姓名：wangwu  、年龄：20
            System.out.println("姓名：" + new String(data, 0, len).trim() + "、年龄：" + raf.readInt());
        }
        {
            // 读取"zhangsan"数据，回跳到0位
            raf.seek(0);
            byte[] data = new byte[8];
            int len = raf.read(data);
            // 姓名：zhangsan、年龄：30
            System.out.println("姓名：" + new String(data, 0, len).trim() + "、年龄：" + raf.readInt());
        }
        raf.close();
    }
}

// 输出内容
姓名：lisi、年龄：16
姓名：wangwu、年龄：20
姓名：zhangsan、年龄：30
```

整体的使用之中由用户自行定义要读取的位置，而后按照指定的结构进行数据的读取。

# 合并流：SequenceInputStream

SequenceInputStream 可以将两个或多个其他 InputStream 合并为一个。 首先，SequenceInputStream 将读取第一个 InputStream 中的所有字节，然后读取第二个 InputStream 中的所有字节。 这就是它被称为 SequenceInputStream 的原因，因为 InputStream 实例是按顺序读取的。

`SequenceInputStream`类的定义和方法

```java
public class SequenceInputStream extends InputStream {}
```

| 方法名                                              | 类型 | 描述                                                  |
| --------------------------------------------------- | ---- | ----------------------------------------------------- |
| SequenceInputStream(InputStream s1, InputStream s2) | 构造 | 通过依次读取两个输入流的数据s1和s2创建新的输入流      |
| SequenceInputStream(Enumeration e)                  | 构造 | 通过读取类型为InputStream的枚举的数据来创建新的输入流 |
| int read()                                          | 普通 | 用于从输入流中读取下一个数据字节                      |
| int read(byte[] , int off, int len)                 | 普通 | 用于将len个字节的数据从输入流读取到字节数组中         |
| int available()                                     | 普通 | 用于返回可从输入流读取的最大字节数                    |
| void close()                                        | 普通 | 用于关闭输入流                                        |

> 组合 2 个 InputStream

操作示例 1：把 2 个流结合【1.txt文件内容为：我们都是、2.txt文件内容：中国人】

```java
package com.example;
import java.io.*;
public class JavaAPIDemo {
    public static void main(String[] args) throws Exception {
        FileInputStream input1 = new FileInputStream("D:\\1.txt");
        FileInputStream input2 = new FileInputStream("D:\\2.txt");
        SequenceInputStream sequenceInputStream = new SequenceInputStream(input1, input2);
        byte[] data = new byte [1024] ;
        int len;
        while ((len = sequenceInputStream.read(data)) != -1) {
            System.out.print((new String(data, 0, len)));
        }
        sequenceInputStream.close();
        input1.close();
        input2.close();
    }
}

// 输出内容
我们都是中国人
```

这里使用了第一个构造函数，直接接收 2 个流，并把他们合并成一个流返回，这样可以使用被组合的两个`InputStream`实例，就像它是一个流一样。但是在读取完成之前，还是不可以关闭被组合的 2 个流，否则再进行读取会抛出异常。

> 组合 2 个以上的 InputStream

操作示例 2：第一种方法是将所有 InputStream 实例放入 Vector 中，并将 Vector.elements() 传递给 SequenceInputStream 构造函数。 下面是一个如何将 Vector 传递给 SequenceInputStream 构造函数的示例：

```java
package com.example;
import java.io.*;
import java.util.Vector;
public class JavaAPIDemo {
    public static void main(String[] args) throws IOException {
        InputStream input1 = new FileInputStream("D:\\1.txt");
        InputStream input2 = new FileInputStream("D:\\2.txt");
        InputStream input3 = new FileInputStream("D:\\3.txt");

        Vector<InputStream> streams = new Vector<>();
        streams.add(input1);
        streams.add(input2);
        streams.add(input3);
        // 利用 Vector 对象的 elements() 方法返回 enumeration 对象
        SequenceInputStream sequenceInputStream = new SequenceInputStream(streams.elements());
        byte[] data = new byte [1024] ;
        int len;
        while ((len = sequenceInputStream.read(data)) != -1) {
            System.out.print((new String(data, 0, len)));
        }
    }
}

// 输出内容
我们都是中国人很开心
```

操作示例 3：第二种方法是将 InputStream 实例两两组合到 SequenceInputStream 实例中，然后再和其他 SequenceInputStream 组合。 以下是实例：

```java
package com.example;
import java.io.FileInputStream;
import java.io.IOException;
import java.io.InputStream;
import java.io.SequenceInputStream;
public class JavaAPIDemo {
    public static void main(String[] args) throws IOException {
        InputStream input1 = new FileInputStream("D:\\1.txt");
        InputStream input2 = new FileInputStream("D:\\2.txt");
        InputStream input3 = new FileInputStream("D:\\3.txt");

        SequenceInputStream sequenceInputStream1 = new SequenceInputStream(input1, input2);
        SequenceInputStream sequenceInputStream = new SequenceInputStream(sequenceInputStream1, input3);
        byte[] data = new byte [1024] ;
        int len;
        while ((len = sequenceInputStream.read(data)) != -1) {
            System.out.print((new String(data, 0, len)));
        }
    }
}

// 输出内容
我们都是中国人很开心
```

源码分析：其实直接传进构造器的 2 个 InputStream ，也会被构造器内部包装成一个 Vector 的。部分源码如下：

```java
public SequenceInputStream(InputStream s1, InputStream s2) {
    Vector<InputStream> v = new Vector<>(2);
    v.addElement(s1);
    v.addElement(s2);
    e = v.elements();
    // ...
}
```

> 关闭 SequenceInputStream

当`SequenceInputStream`关闭时，它还将关闭它从中读取的`InputStream`实例，可以调用`close()`，还可以使用 Java7 中引入的`try-with-resources`自动关闭

查看`SequenceInputStream`关闭资源的源码：

```java
public void close() throws IOException {
    do {
        nextStream();
    } while (in != null);
}

final void nextStream() throws IOException {
    if (in != null) {
        in.close();
    }
    if (e.hasMoreElements()) {
        in = (InputStream) e.nextElement();
        if (in == null)
            throw new NullPointerException();
    }
    else in = null;
}
```



# Properties属性类

# 实战：文件拷贝

实现方案：

- 方案一：使用 InputStream将全部要拷贝的内容直接读取到程序里面，而后一次性的输出到目标文件如果现在拷贝的文件很大，基本上程序就死了
- 方案二：采用部分拷贝，读取一部分输出一部分数据，如果现在要采用第二种做法，核心的操作方法：
  - InputStream：public int read(byte[ b)
  - OutputStream：public void write(byte b, int off, int len)
- 方案三：使用转换流的方式

**范例：**实现文件拷贝处理（InputStream、OutputStream）

```java
package cn.mldn.demo;
import java.io.File;
import java.io.FileInputStream;
import java.io.FileOutputStream;
import java.io.InputStream;
import java.io.OutputStream;
class FileUtil {	// 定义一个文件操作的工具类
	private File srcFile ; // 源文件路径
	private File desFile ; // 目标文件路径
	public FileUtil(String src,String des) {
		this(new File(src),new File(des)) ;
	}
	public FileUtil(File srcFile,File desFile) {
		this.srcFile = srcFile ;
		this.desFile = desFile ;
	}
	public boolean copy() throws Exception {	// 文件拷贝处理
		if (!this.srcFile.exists()) {	// 源文件必须存在!
			System.out.println("拷贝的源文件不存在！");
			return false ; // 拷贝失败
		}
		if (!this.desFile.getParentFile().exists()) { 
			this.desFile.getParentFile().mkdirs() ; // 创建父目录
		}
		byte data [] = new byte[1024] ; // 开辟一个拷贝的缓冲区
		InputStream input = null ;
		OutputStream output = null ;
		try {
			input = new FileInputStream(this.srcFile) ;
			output = new FileOutputStream(this.desFile) ;
			int len = 0 ;
			// 1、读取数据到数组之中，随后返回读取的个数、len = input.read(data)
			// 2、判断个数是否是-1，如果不是则进行写入、(len = input.read(data)) != -1
			while ((len = input.read(data)) != -1) {
				output.write(data, 0, len);
			}
			return true ; 
		} catch (Exception e) {
			throw e ;
		} finally {
			if (input != null) {
				input.close();	
			} 
			if (output != null) {
				output.close() ;
			}
		}
	}
}
public class JavaAPIDemo {
	public static void main(String[] args) throws Exception {
		if (args.length != 2) {	// 程序执行出错
			System.out.println("命令执行错误，执行结构：java JavaAPIDemo 拷贝源文件路径 拷贝目标文件路径");
			System.exit(1); 
		}
		long start = System.currentTimeMillis() ;
		FileUtil fu = new FileUtil(args[0],args[1]) ;
		System.out.println(fu.copy() ? "文件拷贝成功！" : "文件拷贝失败！");
		long end = System.currentTimeMillis() ;
		System.out.println("拷贝完成的时间：" + (end - start));
	}
}
```

**范例：**实现文件拷贝处理（InputStreamReader、OutputStreamWriter）

```java
import java.io.FileInputStream;
import java.io.FileOutputStream;
import java.io.FileReader;
import java.io.FileWriter;
import java.io.IOException;
import java.io.InputStreamReader;
import java.io.OutputStreamWriter;
 
/**
* @author Manduner_TJU
* @version 创建时间：2018年11月2日下午10:13:01
*/
public class TestIO {
	public static void main(String[] args) throws IOException{
		//copyChar1("e:\\test.json","g:\\testNew.json");
		//copyChar11("e:\\test.json","g:\\testNew.json");
		//copyChar2("e:\\test.json","g:\\testNew.json");
		copyChar22("e:\\test.json","g:\\testNew.json");
		System.out.println("文件复制完毕");
	}
	
	//InputStreamReader、OutputStreamWriter通过字符数组传递数据流
	public static void copyChar1(String source, String des) throws IOException{
		//1,封装数据源
		InputStreamReader isr = new InputStreamReader(
				new FileInputStream(source),"gbk");
		OutputStreamWriter osw = new OutputStreamWriter(
				new FileOutputStream(des),"gbk");
		//2,复制文件
		char[] ch = new char[1024];
		int len = 0;
		while((len = isr.read(ch)) !=-1) {
			osw.write(ch,0,len);
		}
		//3,释放资源
		isr.close();
		osw.close();
	}
	
	//InputStreamReader、OutputStreamWriter通过字符传递数据流
	public static void copyChar11(String source, String des) throws IOException{
		//1,封装数据源
		InputStreamReader isr = new InputStreamReader(new FileInputStream(source));
		OutputStreamWriter osw = new OutputStreamWriter(new FileOutputStream(des));
		
		//3,复制文件
		int ch = 0;
		while((ch=isr.read())!=-1) {
			osw.write(ch);
		}
		
		//2,释放资源
		isr.close();
		osw.close();
		
	}
	//FileReader,FileWriter通过字符数组传递数据流
	public static void copyChar2(String source, String des) throws IOException{
		//1,封装数据源
		FileReader fr = new FileReader(source);
		FileWriter fw = new FileWriter(des);
		
		//2,复制文件
		char[] ch = new char[1024];
		int len = 0;
		while((len = fr.read(ch)) != -1) {
			fw.write(ch,0,len);
		}
		
		//3,释放资源
		fr.close();
		fw.close();
	}
	//FileReader,FileWriter通过字符传递数据流
	public static void copyChar22(String source, String des) throws IOException{
		//1,封装资源
		FileReader fr = new FileReader(source);
		FileWriter fw = new FileWriter(des);
		
		//2,复制文件
		int ch = 0;
		while((ch=fr.read())!=-1) {
			fw.write(ch);
		}
		
		//3,释放资源
		fr.close();
		fw.close();
	}
}
```



​		但是需要注意的是,以上的做法是属于文件拷贝的最原始实现，而从JDK19开始 InputStream和 Reader类中都追加有数据转存的处理操作方法：

- InputStream：public long transferTo(OutputStream out):
- Reader：public long transferTo(Writer out)

**范例：**使用转存的方式处理

```java
package cn.mldn.demo;

import java.io.File;
import java.io.FileInputStream;
import java.io.FileOutputStream;
import java.io.InputStream;
import java.io.OutputStream;
class FileUtil {	// 定义一个文件操作的工具类
	private File srcFile ; // 源文件路径
	private File desFile ; // 目标文件路径
	public FileUtil(String src,String des) {
		this(new File(src),new File(des)) ;
	}
	public FileUtil(File srcFile,File desFile) {
		this.srcFile = srcFile ;
		this.desFile = desFile ;
	}
	public boolean copy() throws Exception {	// 文件拷贝处理
		if (!this.srcFile.exists()) {	// 源文件必须存在!
			System.out.println("拷贝的源文件不存在！");
			return false ; // 拷贝失败
		}
		if (!this.desFile.getParentFile().exists()) { 
			this.desFile.getParentFile().mkdirs() ; // 创建父目录
		}
		InputStream input = null ;
		OutputStream output = null ;
		try {
			input = new FileInputStream(this.srcFile) ;
			output = new FileOutputStream(this.desFile) ;
			input.transferTo(output) ;
			return true ; 
		} catch (Exception e) {
			throw e ;
		} finally {
			if (input != null) {
				input.close();	
			} 
			if (output != null) {
				output.close() ;
			}
		}
	}
}
public class JavaAPIDemo {
	public static void main(String[] args) throws Exception {
		if (args.length != 2) {	// 程序执行出错
			System.out.println("命令执行错误，执行结构：java JavaAPIDemo 拷贝源文件路径 拷贝目标文件路径");
			System.exit(1); 
		}
		long start = System.currentTimeMillis() ;
		FileUtil fu = new FileUtil(args[0],args[1]) ;
		System.out.println(fu.copy() ? "文件拷贝成功！" : "文件拷贝失败！");
		long end = System.currentTimeMillis() ;
		System.out.println("拷贝完成的时间：" + (end - start));
	}
}
```

​		此时千万要注意程序的运行版本问题。那么如果说现在对此程序要求进一步扩展,可以实现一个文件目录的拷贝呢?一旦进行了文件目录的拷贝还需要拷贝所有的子目录中的文件。

范例：文件夹拷贝（递归）

```java
package cn.mldn.demo;

import java.io.File;
import java.io.FileInputStream;
import java.io.FileOutputStream;
import java.io.InputStream;
import java.io.OutputStream;
class FileUtil {	// 定义一个文件操作的工具类
	private File srcFile ; // 源文件路径
	private File desFile ; // 目标文件路径
	public FileUtil(String src,String des) {
		this(new File(src),new File(des)) ;
	}
	public FileUtil(File srcFile,File desFile) {
		this.srcFile = srcFile ;
		this.desFile = desFile ;
	}
	public boolean copyDir() throws Exception {
		try {
			this.copyImpl(this.srcFile) ;
			return true ;
		} catch (Exception e) {
			return false ; 
		}
	}
	private void copyImpl(File file) throws Exception {	// 递归操作
		if (file.isDirectory()) {	// 是目录
			File results [] = file.listFiles() ; // 列出全部目录组成
			if (results != null) {
				for (int x = 0 ; x < results.length ; x ++) {
					copyImpl(results[x]) ;
				}
			}
		} else {	// 是文件
			String newFilePath = file.getPath().replace(this.srcFile.getPath() + File.separator, "") ;
			File newFile = new File(this.desFile,newFilePath) ; // 拷贝的目标路径
			this.copyFileImpl(file, newFile) ;
		}
	}
	private boolean copyFileImpl(File srcFile,File desFile) throws Exception {
		if (!desFile.getParentFile().exists()) { 
			desFile.getParentFile().mkdirs() ; // 创建父目录
		}
		InputStream input = null ;
		OutputStream output = null ;
		try {
			input = new FileInputStream(srcFile) ;
			output = new FileOutputStream(desFile) ;
			input.transferTo(output) ;
			return true ;
		} catch (Exception e) {
			throw e ;
		} finally {
			if (input != null) {
				input.close();	
			} 
			if (output != null) {
				output.close() ;
			}
		}
	}
	
	public boolean copy() throws Exception {	// 文件拷贝处理
		if (!this.srcFile.exists()) {	// 源文件必须存在!
			System.out.println("拷贝的源文件不存在！");
			return false ; // 拷贝失败
		}
		return this.copyFileImpl(this.srcFile, this.desFile) ;
	}
}
public class JavaAPIDemo {
	public static void main(String[] args) throws Exception {
		if (args.length != 2) {	// 程序执行出错
			System.out.println("命令执行错误，执行结构：java JavaAPIDemo 拷贝源文件路径 拷贝目标文件路径");
			System.exit(1); 
		}
		long start = System.currentTimeMillis() ;
		FileUtil fu = new FileUtil(args[0],args[1]) ;
		if (new File(args[0]).isFile()) {	// 文件拷贝
			System.out.println(fu.copy() ? "文件拷贝成功！" : "文件拷贝失败！");
		} else {	// 目录拷贝
			System.out.println(fu.copyDir() ? "文件拷贝成功！" : "文件拷贝失败！");
		}
		long end = System.currentTimeMillis() ;
		System.out.println("拷贝完成的时间：" + (end - start));
	}
}
```



# 实战：文件压缩

1. https://blog.csdn.net/m0_46379371/article/details/115920433
2. https://blog.csdn.net/LightStrikeHonor/article/details/116948602
3. https://www.cnblogs.com/lrh-xl/p/5509005.html

```java
public class ZipCompressor {

    static final int BUFFER = 8192;

    private File zipFile;

    /**
     * 压缩器构造函数
     *
     * @param pathName 压缩包路径<br> e.g /Users/Admin/Desktop/test.zip
     */
    public ZipCompressor(String pathName) {
        zipFile = new File(pathName);
    }

    public void compress(String... pathName) {
        ZipOutputStream out = null;
        try {
            FileOutputStream fileOutputStream = new FileOutputStream(zipFile);
            CheckedOutputStream cos = new CheckedOutputStream(fileOutputStream,
                                                              new CRC32());
            out = new ZipOutputStream(cos);
            String basedir = "";
            for (int i = 0; i < pathName.length; i++) {
                compress(new File(pathName[i]), out, basedir);
            }
            out.close();
        } catch (Exception e) {
            throw new RuntimeException(e);
        }
    }

    /**
     * 压缩一个文件,或者一个文件夹
     *
     * @param srcPathName 文件路径,或文件夹路径
     */
    public void compress(String srcPathName) {
        File file = new File(srcPathName);
        if (!file.exists()) {
            throw new RuntimeException(srcPathName + "不存在！");
        }
        try {
            FileOutputStream fileOutputStream = new FileOutputStream(zipFile);
            CheckedOutputStream cos = new CheckedOutputStream(fileOutputStream,
                                                              new CRC32());
            ZipOutputStream out = new ZipOutputStream(cos);
            String basedir = "";
            compress(file, out, basedir);
            out.close();
        } catch (Exception e) {
            throw new RuntimeException(e);
        }
    }

    private void compress(File file, ZipOutputStream out, String basedir) {
        /* 判断是目录还是文件 */
        if (file.isDirectory()) {
            System.out.println("压缩：" + basedir + file.getName());
            this.compressDirectory(file, out, basedir);
        } else {
            System.out.println("压缩：" + basedir + file.getName());
            this.compressFile(file, out, basedir);
        }
    }

    /**
     * 压缩一个目录
     */
    private void compressDirectory(File dir, ZipOutputStream out, String basedir) {
        if (!dir.exists()) {
            return;
        }

        File[] files = dir.listFiles();
        if (files != null) {
            if (files.length == 0) {
                try {
                    out.putNextEntry(new ZipEntry(basedir + dir.getName() + File.separator));
                } catch (Exception e) {
                    e.printStackTrace();
                }
            } else {
                for (int i = 0; i < files.length; i++) {
                    /* 递归 */
                    compress(files[i], out, basedir + dir.getName() + "/");
                }
            }
        }
    }

    /**
     * 压缩一个文件
     */
    private void compressFile(File file, ZipOutputStream out, String basedir) {
        if (!file.exists()) {
            return;
        }
        try {
            BufferedInputStream bis = new BufferedInputStream(
                new FileInputStream(file));
            ZipEntry entry = new ZipEntry(basedir + file.getName());
            out.putNextEntry(entry);
            int count;
            byte data[] = new byte[BUFFER];
            while ((count = bis.read(data, 0, BUFFER)) != -1) {
                out.write(data, 0, count);
            }
            bis.close();
        } catch (Exception e) {
            throw new RuntimeException(e);
        }
    }


    /**
     * 以流的形式下载文件
     *
     * @param file
     * @param response
     */
    public static HttpServletResponse downloadZip(File file, HttpServletResponse response) {
        try {
            // 以流的形式下载文件。
            InputStream fis = new BufferedInputStream(new FileInputStream(file.getPath()));
            byte[] buffer = new byte[fis.available()];
            fis.read(buffer);
            fis.close();
            // 清空response
            response.reset();
            OutputStream toClient = new BufferedOutputStream(response.getOutputStream());
            // response.setContentType("application/octet-stream");
            response.setContentType("application/x-zip-compressed");
            //如果输出的是中文名的文件，在此处就要用URLEncoder.encode方法进行处理
            response.setHeader("Content-Disposition",
                               "attachment;filename=" + URLEncoder.encode(file.getName(), "UTF-8"));
            toClient.write(buffer);
            toClient.flush();
            toClient.close();
        } catch (IOException ex) {
            ex.printStackTrace();
        } finally {
            try {
                if (file.exists()) {
                    file.delete();
                }
            } catch (Exception e) {
                e.printStackTrace();
            }
        }
        return response;
    }
｝
```

